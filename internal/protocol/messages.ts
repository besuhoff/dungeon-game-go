// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "messages.proto" (package "protocol", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType as MessageType$ } from "@protobuf-ts/runtime";
/**
 * Common structures
 *
 * @generated from protobuf message protocol.Vector2
 */
export interface Vector2 {
    /**
     * @generated from protobuf field: double x = 1
     */
    x: number;
    /**
     * @generated from protobuf field: double y = 2
     */
    y: number;
}
/**
 * @generated from protobuf message protocol.InventoryItem
 */
export interface InventoryItem {
    /**
     * @generated from protobuf field: int32 type = 1
     */
    type: number;
    /**
     * @generated from protobuf field: int32 quantity = 2
     */
    quantity: number;
}
/**
 * @generated from protobuf message protocol.Player
 */
export interface Player {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string username = 2
     */
    username: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 3
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: protocol.Vector2 velocity = 4
     */
    velocity?: Vector2;
    /**
     * @generated from protobuf field: float lives = 5
     */
    lives: number;
    /**
     * @generated from protobuf field: double invulnerable_timer = 13
     */
    invulnerableTimer: number;
    /**
     * @generated from protobuf field: int32 score = 6
     */
    score: number;
    /**
     * @generated from protobuf field: int32 money = 7
     */
    money: number;
    /**
     * @generated from protobuf field: int32 kills = 8
     */
    kills: number;
    /**
     * @generated from protobuf field: double rotation = 9
     */
    rotation: number;
    /**
     * @generated from protobuf field: map<string, int32> bullets_left_by_weapon_type = 10
     */
    bulletsLeftByWeaponType: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: double night_vision_timer = 11
     */
    nightVisionTimer: number;
    /**
     * @generated from protobuf field: bool is_alive = 12
     */
    isAlive: boolean;
    /**
     * @generated from protobuf field: repeated protocol.InventoryItem inventory = 14
     */
    inventory: InventoryItem[];
    /**
     * @generated from protobuf field: string selected_gun_type = 15
     */
    selectedGunType: string;
}
/**
 * @generated from protobuf message protocol.Bullet
 */
export interface Bullet {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: protocol.Vector2 velocity = 3
     */
    velocity?: Vector2;
    /**
     * @generated from protobuf field: string owner_id = 4
     */
    ownerId: string;
    /**
     * @generated from protobuf field: float damage = 5
     */
    damage: number;
    /**
     * @generated from protobuf field: bool is_enemy = 6
     */
    isEnemy: boolean;
    /**
     * @generated from protobuf field: bool is_active = 7
     */
    isActive: boolean;
    /**
     * @generated from protobuf field: int64 deleted_at = 10
     */
    deletedAt: bigint;
    /**
     * @generated from protobuf field: int64 inactive_ms = 9
     */
    inactiveMs: bigint;
    /**
     * @generated from protobuf field: string weapon_type = 8
     */
    weaponType: string;
}
/**
 * @generated from protobuf message protocol.Wall
 */
export interface Wall {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: double width = 3
     */
    width: number;
    /**
     * @generated from protobuf field: double height = 4
     */
    height: number;
    /**
     * @generated from protobuf field: string orientation = 5
     */
    orientation: string;
}
/**
 * @generated from protobuf message protocol.Enemy
 */
export interface Enemy {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: double rotation = 3
     */
    rotation: number;
    /**
     * @generated from protobuf field: float lives = 4
     */
    lives: number;
    /**
     * @generated from protobuf field: string wall_id = 5
     */
    wallId: string;
    /**
     * @generated from protobuf field: bool is_dead = 6
     */
    isDead: boolean;
}
/**
 * @generated from protobuf message protocol.Bonus
 */
export interface Bonus {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: string type = 3
     */
    type: string;
    /**
     * @generated from protobuf field: string picked_up_by = 4
     */
    pickedUpBy: string;
    /**
     * @generated from protobuf field: string dropped_by = 5
     */
    droppedBy: string;
}
/**
 * @generated from protobuf message protocol.ShopItem
 */
export interface ShopItem {
    /**
     * @generated from protobuf field: int32 quantity = 1
     */
    quantity: number;
    /**
     * @generated from protobuf field: int32 pack_size = 2
     */
    packSize: number;
    /**
     * @generated from protobuf field: int32 price = 3
     */
    price: number;
}
/**
 * @generated from protobuf message protocol.Shop
 */
export interface Shop {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: map<int32, protocol.ShopItem> inventory = 3
     */
    inventory: {
        [key: number]: ShopItem;
    };
    /**
     * @generated from protobuf field: string name = 4
     */
    name: string;
}
/**
 * @generated from protobuf message protocol.InputMessage
 */
export interface InputMessage {
    /**
     * @generated from protobuf field: bool forward = 1
     */
    forward: boolean;
    /**
     * @generated from protobuf field: bool backward = 2
     */
    backward: boolean;
    /**
     * @generated from protobuf field: bool left = 3
     */
    left: boolean;
    /**
     * @generated from protobuf field: bool right = 4
     */
    right: boolean;
    /**
     * @generated from protobuf field: bool shoot = 5
     */
    shoot: boolean;
    /**
     * @generated from protobuf field: map<int32, bool> item_key = 6
     */
    itemKey: {
        [key: number]: boolean;
    };
    /**
     * @generated from protobuf field: map<int32, bool> purchase_item_key = 7
     */
    purchaseItemKey: {
        [key: number]: boolean;
    };
}
/**
 * Server -> Client messages
 *
 * @generated from protobuf message protocol.GameStateMessage
 */
export interface GameStateMessage {
    /**
     * @generated from protobuf field: map<string, protocol.Player> players = 1
     */
    players: {
        [key: string]: Player;
    };
    /**
     * @generated from protobuf field: map<string, protocol.Bullet> bullets = 2
     */
    bullets: {
        [key: string]: Bullet;
    };
    /**
     * @generated from protobuf field: map<string, protocol.Wall> walls = 3
     */
    walls: {
        [key: string]: Wall;
    };
    /**
     * @generated from protobuf field: map<string, protocol.Enemy> enemies = 4
     */
    enemies: {
        [key: string]: Enemy;
    };
    /**
     * @generated from protobuf field: map<string, protocol.Bonus> bonuses = 5
     */
    bonuses: {
        [key: string]: Bonus;
    };
    /**
     * @generated from protobuf field: map<string, protocol.Shop> shops = 7
     */
    shops: {
        [key: string]: Shop;
    };
    /**
     * @generated from protobuf field: repeated string players_shops = 8
     */
    playersShops: string[];
    /**
     * @generated from protobuf field: int64 timestamp = 6
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message protocol.GameStateDeltaMessage
 */
export interface GameStateDeltaMessage {
    /**
     * @generated from protobuf field: map<string, protocol.Player> updated_players = 1
     */
    updatedPlayers: {
        [key: string]: Player;
    };
    /**
     * @generated from protobuf field: repeated string removed_players = 2
     */
    removedPlayers: string[];
    /**
     * @generated from protobuf field: map<string, protocol.Bullet> updated_bullets = 3
     */
    updatedBullets: {
        [key: string]: Bullet;
    };
    /**
     * @generated from protobuf field: map<string, protocol.Bullet> removed_bullets = 4
     */
    removedBullets: {
        [key: string]: Bullet;
    };
    /**
     * @generated from protobuf field: map<string, protocol.Wall> updated_walls = 5
     */
    updatedWalls: {
        [key: string]: Wall;
    };
    /**
     * @generated from protobuf field: repeated string removed_walls = 6
     */
    removedWalls: string[];
    /**
     * @generated from protobuf field: map<string, protocol.Enemy> updated_enemies = 7
     */
    updatedEnemies: {
        [key: string]: Enemy;
    };
    /**
     * @generated from protobuf field: repeated string removed_enemies = 8
     */
    removedEnemies: string[];
    /**
     * @generated from protobuf field: map<string, protocol.Bonus> updated_bonuses = 9
     */
    updatedBonuses: {
        [key: string]: Bonus;
    };
    /**
     * @generated from protobuf field: repeated string removed_bonuses = 10
     */
    removedBonuses: string[];
    /**
     * @generated from protobuf field: map<string, protocol.Shop> updated_shops = 12
     */
    updatedShops: {
        [key: string]: Shop;
    };
    /**
     * @generated from protobuf field: repeated string removed_shops = 13
     */
    removedShops: string[];
    /**
     * @generated from protobuf field: repeated string players_shops = 14
     */
    playersShops: string[];
    /**
     * @generated from protobuf field: int64 timestamp = 11
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message protocol.PlayerJoinMessage
 */
export interface PlayerJoinMessage {
    /**
     * @generated from protobuf field: protocol.Player player = 1
     */
    player?: Player;
}
/**
 * @generated from protobuf message protocol.PlayerLeaveMessage
 */
export interface PlayerLeaveMessage {
    /**
     * @generated from protobuf field: string player_id = 1
     */
    playerId: string;
}
/**
 * @generated from protobuf message protocol.PlayerRespawnMessage
 */
export interface PlayerRespawnMessage {
}
/**
 * @generated from protobuf message protocol.ErrorMessage
 */
export interface ErrorMessage {
    /**
     * @generated from protobuf field: string message = 1
     */
    message: string;
}
/**
 * Wrapper message
 *
 * @generated from protobuf message protocol.GameMessage
 */
export interface GameMessage {
    /**
     * @generated from protobuf field: protocol.MessageType type = 1
     */
    type: MessageType;
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "input";
        /**
         * @generated from protobuf field: protocol.InputMessage input = 3
         */
        input: InputMessage;
    } | {
        oneofKind: "gameState";
        /**
         * @generated from protobuf field: protocol.GameStateMessage game_state = 5
         */
        gameState: GameStateMessage;
    } | {
        oneofKind: "gameStateDelta";
        /**
         * @generated from protobuf field: protocol.GameStateDeltaMessage game_state_delta = 11
         */
        gameStateDelta: GameStateDeltaMessage;
    } | {
        oneofKind: "playerJoin";
        /**
         * @generated from protobuf field: protocol.PlayerJoinMessage player_join = 6
         */
        playerJoin: PlayerJoinMessage;
    } | {
        oneofKind: "playerLeave";
        /**
         * @generated from protobuf field: protocol.PlayerLeaveMessage player_leave = 7
         */
        playerLeave: PlayerLeaveMessage;
    } | {
        oneofKind: "playerRespawn";
        /**
         * @generated from protobuf field: protocol.PlayerRespawnMessage player_respawn = 8
         */
        playerRespawn: PlayerRespawnMessage;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: protocol.ErrorMessage error = 10
         */
        error: ErrorMessage;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Message types
 *
 * @generated from protobuf enum protocol.MessageType
 */
export enum MessageType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: INPUT = 2;
     */
    INPUT = 2,
    /**
     * @generated from protobuf enum value: GAME_STATE = 5;
     */
    GAME_STATE = 5,
    /**
     * @generated from protobuf enum value: GAME_STATE_DELTA = 11;
     */
    GAME_STATE_DELTA = 11,
    /**
     * @generated from protobuf enum value: PLAYER_JOIN = 6;
     */
    PLAYER_JOIN = 6,
    /**
     * @generated from protobuf enum value: PLAYER_LEAVE = 7;
     */
    PLAYER_LEAVE = 7,
    /**
     * @generated from protobuf enum value: PLAYER_RESPAWN = 8;
     */
    PLAYER_RESPAWN = 8,
    /**
     * @generated from protobuf enum value: ERROR = 10;
     */
    ERROR = 10
}
// @generated message type with reflection information, may provide speed optimized methods
class Vector2$Type extends MessageType$<Vector2> {
    constructor() {
        super("protocol.Vector2", [
            { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Vector2>): Vector2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<Vector2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vector2): Vector2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double x */ 1:
                    message.x = reader.double();
                    break;
                case /* double y */ 2:
                    message.y = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vector2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit64).double(message.x);
        /* double y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit64).double(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Vector2
 */
export const Vector2 = new Vector2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InventoryItem$Type extends MessageType$<InventoryItem> {
    constructor() {
        super("protocol.InventoryItem", [
            { no: 1, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<InventoryItem>): InventoryItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.quantity = 0;
        if (value !== undefined)
            reflectionMergePartial<InventoryItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InventoryItem): InventoryItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* int32 quantity */ 2:
                    message.quantity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InventoryItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* int32 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int32(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.InventoryItem
 */
export const InventoryItem = new InventoryItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player$Type extends MessageType$<Player> {
    constructor() {
        super("protocol.Player", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "position", kind: "message", T: () => Vector2 },
            { no: 4, name: "velocity", kind: "message", T: () => Vector2 },
            { no: 5, name: "lives", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "invulnerable_timer", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "money", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "kills", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "rotation", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "bullets_left_by_weapon_type", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 11, name: "night_vision_timer", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "is_alive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "inventory", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => InventoryItem },
            { no: 15, name: "selected_gun_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Player>): Player {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.username = "";
        message.lives = 0;
        message.invulnerableTimer = 0;
        message.score = 0;
        message.money = 0;
        message.kills = 0;
        message.rotation = 0;
        message.bulletsLeftByWeaponType = {};
        message.nightVisionTimer = 0;
        message.isAlive = false;
        message.inventory = [];
        message.selectedGunType = "";
        if (value !== undefined)
            reflectionMergePartial<Player>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Player): Player {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string username */ 2:
                    message.username = reader.string();
                    break;
                case /* protocol.Vector2 position */ 3:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* protocol.Vector2 velocity */ 4:
                    message.velocity = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                case /* float lives */ 5:
                    message.lives = reader.float();
                    break;
                case /* double invulnerable_timer */ 13:
                    message.invulnerableTimer = reader.double();
                    break;
                case /* int32 score */ 6:
                    message.score = reader.int32();
                    break;
                case /* int32 money */ 7:
                    message.money = reader.int32();
                    break;
                case /* int32 kills */ 8:
                    message.kills = reader.int32();
                    break;
                case /* double rotation */ 9:
                    message.rotation = reader.double();
                    break;
                case /* map<string, int32> bullets_left_by_weapon_type */ 10:
                    this.binaryReadMap10(message.bulletsLeftByWeaponType, reader, options);
                    break;
                case /* double night_vision_timer */ 11:
                    message.nightVisionTimer = reader.double();
                    break;
                case /* bool is_alive */ 12:
                    message.isAlive = reader.bool();
                    break;
                case /* repeated protocol.InventoryItem inventory */ 14:
                    message.inventory.push(InventoryItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string selected_gun_type */ 15:
                    message.selectedGunType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: Player["bulletsLeftByWeaponType"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Player["bulletsLeftByWeaponType"] | undefined, val: Player["bulletsLeftByWeaponType"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.Player.bullets_left_by_weapon_type");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: Player, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string username = 2; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* protocol.Vector2 position = 3; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* protocol.Vector2 velocity = 4; */
        if (message.velocity)
            Vector2.internalBinaryWrite(message.velocity, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* float lives = 5; */
        if (message.lives !== 0)
            writer.tag(5, WireType.Bit32).float(message.lives);
        /* int32 score = 6; */
        if (message.score !== 0)
            writer.tag(6, WireType.Varint).int32(message.score);
        /* int32 money = 7; */
        if (message.money !== 0)
            writer.tag(7, WireType.Varint).int32(message.money);
        /* int32 kills = 8; */
        if (message.kills !== 0)
            writer.tag(8, WireType.Varint).int32(message.kills);
        /* double rotation = 9; */
        if (message.rotation !== 0)
            writer.tag(9, WireType.Bit64).double(message.rotation);
        /* map<string, int32> bullets_left_by_weapon_type = 10; */
        for (let k of globalThis.Object.keys(message.bulletsLeftByWeaponType))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.bulletsLeftByWeaponType[k]).join();
        /* double night_vision_timer = 11; */
        if (message.nightVisionTimer !== 0)
            writer.tag(11, WireType.Bit64).double(message.nightVisionTimer);
        /* bool is_alive = 12; */
        if (message.isAlive !== false)
            writer.tag(12, WireType.Varint).bool(message.isAlive);
        /* double invulnerable_timer = 13; */
        if (message.invulnerableTimer !== 0)
            writer.tag(13, WireType.Bit64).double(message.invulnerableTimer);
        /* repeated protocol.InventoryItem inventory = 14; */
        for (let i = 0; i < message.inventory.length; i++)
            InventoryItem.internalBinaryWrite(message.inventory[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string selected_gun_type = 15; */
        if (message.selectedGunType !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.selectedGunType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Player
 */
export const Player = new Player$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bullet$Type extends MessageType$<Bullet> {
    constructor() {
        super("protocol.Bullet", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "velocity", kind: "message", T: () => Vector2 },
            { no: 4, name: "owner_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "damage", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "is_enemy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "deleted_at", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "inactive_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "weapon_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Bullet>): Bullet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.ownerId = "";
        message.damage = 0;
        message.isEnemy = false;
        message.isActive = false;
        message.deletedAt = 0n;
        message.inactiveMs = 0n;
        message.weaponType = "";
        if (value !== undefined)
            reflectionMergePartial<Bullet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bullet): Bullet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* protocol.Vector2 velocity */ 3:
                    message.velocity = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                case /* string owner_id */ 4:
                    message.ownerId = reader.string();
                    break;
                case /* float damage */ 5:
                    message.damage = reader.float();
                    break;
                case /* bool is_enemy */ 6:
                    message.isEnemy = reader.bool();
                    break;
                case /* bool is_active */ 7:
                    message.isActive = reader.bool();
                    break;
                case /* int64 deleted_at */ 10:
                    message.deletedAt = reader.int64().toBigInt();
                    break;
                case /* int64 inactive_ms */ 9:
                    message.inactiveMs = reader.int64().toBigInt();
                    break;
                case /* string weapon_type */ 8:
                    message.weaponType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bullet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* protocol.Vector2 velocity = 3; */
        if (message.velocity)
            Vector2.internalBinaryWrite(message.velocity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string owner_id = 4; */
        if (message.ownerId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ownerId);
        /* float damage = 5; */
        if (message.damage !== 0)
            writer.tag(5, WireType.Bit32).float(message.damage);
        /* bool is_enemy = 6; */
        if (message.isEnemy !== false)
            writer.tag(6, WireType.Varint).bool(message.isEnemy);
        /* bool is_active = 7; */
        if (message.isActive !== false)
            writer.tag(7, WireType.Varint).bool(message.isActive);
        /* string weapon_type = 8; */
        if (message.weaponType !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.weaponType);
        /* int64 inactive_ms = 9; */
        if (message.inactiveMs !== 0n)
            writer.tag(9, WireType.Varint).int64(message.inactiveMs);
        /* int64 deleted_at = 10; */
        if (message.deletedAt !== 0n)
            writer.tag(10, WireType.Varint).int64(message.deletedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Bullet
 */
export const Bullet = new Bullet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Wall$Type extends MessageType$<Wall> {
    constructor() {
        super("protocol.Wall", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "width", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "height", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "orientation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Wall>): Wall {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.width = 0;
        message.height = 0;
        message.orientation = "";
        if (value !== undefined)
            reflectionMergePartial<Wall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Wall): Wall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* double width */ 3:
                    message.width = reader.double();
                    break;
                case /* double height */ 4:
                    message.height = reader.double();
                    break;
                case /* string orientation */ 5:
                    message.orientation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Wall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* double width = 3; */
        if (message.width !== 0)
            writer.tag(3, WireType.Bit64).double(message.width);
        /* double height = 4; */
        if (message.height !== 0)
            writer.tag(4, WireType.Bit64).double(message.height);
        /* string orientation = 5; */
        if (message.orientation !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.orientation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Wall
 */
export const Wall = new Wall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Enemy$Type extends MessageType$<Enemy> {
    constructor() {
        super("protocol.Enemy", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "rotation", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "lives", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "wall_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "is_dead", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Enemy>): Enemy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.rotation = 0;
        message.lives = 0;
        message.wallId = "";
        message.isDead = false;
        if (value !== undefined)
            reflectionMergePartial<Enemy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Enemy): Enemy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* double rotation */ 3:
                    message.rotation = reader.double();
                    break;
                case /* float lives */ 4:
                    message.lives = reader.float();
                    break;
                case /* string wall_id */ 5:
                    message.wallId = reader.string();
                    break;
                case /* bool is_dead */ 6:
                    message.isDead = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Enemy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* double rotation = 3; */
        if (message.rotation !== 0)
            writer.tag(3, WireType.Bit64).double(message.rotation);
        /* float lives = 4; */
        if (message.lives !== 0)
            writer.tag(4, WireType.Bit32).float(message.lives);
        /* string wall_id = 5; */
        if (message.wallId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.wallId);
        /* bool is_dead = 6; */
        if (message.isDead !== false)
            writer.tag(6, WireType.Varint).bool(message.isDead);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Enemy
 */
export const Enemy = new Enemy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bonus$Type extends MessageType$<Bonus> {
    constructor() {
        super("protocol.Bonus", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "picked_up_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "dropped_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Bonus>): Bonus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.type = "";
        message.pickedUpBy = "";
        message.droppedBy = "";
        if (value !== undefined)
            reflectionMergePartial<Bonus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bonus): Bonus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                case /* string picked_up_by */ 4:
                    message.pickedUpBy = reader.string();
                    break;
                case /* string dropped_by */ 5:
                    message.droppedBy = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bonus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* string picked_up_by = 4; */
        if (message.pickedUpBy !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pickedUpBy);
        /* string dropped_by = 5; */
        if (message.droppedBy !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.droppedBy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Bonus
 */
export const Bonus = new Bonus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopItem$Type extends MessageType$<ShopItem> {
    constructor() {
        super("protocol.ShopItem", [
            { no: 1, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "pack_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "price", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ShopItem>): ShopItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.quantity = 0;
        message.packSize = 0;
        message.price = 0;
        if (value !== undefined)
            reflectionMergePartial<ShopItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopItem): ShopItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 quantity */ 1:
                    message.quantity = reader.int32();
                    break;
                case /* int32 pack_size */ 2:
                    message.packSize = reader.int32();
                    break;
                case /* int32 price */ 3:
                    message.price = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 quantity = 1; */
        if (message.quantity !== 0)
            writer.tag(1, WireType.Varint).int32(message.quantity);
        /* int32 pack_size = 2; */
        if (message.packSize !== 0)
            writer.tag(2, WireType.Varint).int32(message.packSize);
        /* int32 price = 3; */
        if (message.price !== 0)
            writer.tag(3, WireType.Varint).int32(message.price);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.ShopItem
 */
export const ShopItem = new ShopItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Shop$Type extends MessageType$<Shop> {
    constructor() {
        super("protocol.Shop", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "inventory", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => ShopItem } },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Shop>): Shop {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.inventory = {};
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Shop>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Shop): Shop {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* map<int32, protocol.ShopItem> inventory */ 3:
                    this.binaryReadMap3(message.inventory, reader, options);
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: Shop["inventory"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Shop["inventory"] | undefined, val: Shop["inventory"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = ShopItem.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.Shop.inventory");
            }
        }
        map[key ?? 0] = val ?? ShopItem.create();
    }
    internalBinaryWrite(message: Shop, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* map<int32, protocol.ShopItem> inventory = 3; */
        for (let k of globalThis.Object.keys(message.inventory)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            ShopItem.internalBinaryWrite(message.inventory[k as any], writer, options);
            writer.join().join();
        }
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Shop
 */
export const Shop = new Shop$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InputMessage$Type extends MessageType$<InputMessage> {
    constructor() {
        super("protocol.InputMessage", [
            { no: 1, name: "forward", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "backward", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "left", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "right", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "shoot", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "item_key", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } },
            { no: 7, name: "purchase_item_key", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } }
        ]);
    }
    create(value?: PartialMessage<InputMessage>): InputMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.forward = false;
        message.backward = false;
        message.left = false;
        message.right = false;
        message.shoot = false;
        message.itemKey = {};
        message.purchaseItemKey = {};
        if (value !== undefined)
            reflectionMergePartial<InputMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InputMessage): InputMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool forward */ 1:
                    message.forward = reader.bool();
                    break;
                case /* bool backward */ 2:
                    message.backward = reader.bool();
                    break;
                case /* bool left */ 3:
                    message.left = reader.bool();
                    break;
                case /* bool right */ 4:
                    message.right = reader.bool();
                    break;
                case /* bool shoot */ 5:
                    message.shoot = reader.bool();
                    break;
                case /* map<int32, bool> item_key */ 6:
                    this.binaryReadMap6(message.itemKey, reader, options);
                    break;
                case /* map<int32, bool> purchase_item_key */ 7:
                    this.binaryReadMap7(message.purchaseItemKey, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: InputMessage["itemKey"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof InputMessage["itemKey"] | undefined, val: InputMessage["itemKey"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.InputMessage.item_key");
            }
        }
        map[key ?? 0] = val ?? false;
    }
    private binaryReadMap7(map: InputMessage["purchaseItemKey"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof InputMessage["purchaseItemKey"] | undefined, val: InputMessage["purchaseItemKey"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.InputMessage.purchase_item_key");
            }
        }
        map[key ?? 0] = val ?? false;
    }
    internalBinaryWrite(message: InputMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool forward = 1; */
        if (message.forward !== false)
            writer.tag(1, WireType.Varint).bool(message.forward);
        /* bool backward = 2; */
        if (message.backward !== false)
            writer.tag(2, WireType.Varint).bool(message.backward);
        /* bool left = 3; */
        if (message.left !== false)
            writer.tag(3, WireType.Varint).bool(message.left);
        /* bool right = 4; */
        if (message.right !== false)
            writer.tag(4, WireType.Varint).bool(message.right);
        /* bool shoot = 5; */
        if (message.shoot !== false)
            writer.tag(5, WireType.Varint).bool(message.shoot);
        /* map<int32, bool> item_key = 6; */
        for (let k of globalThis.Object.keys(message.itemKey))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).bool(message.itemKey[k as any]).join();
        /* map<int32, bool> purchase_item_key = 7; */
        for (let k of globalThis.Object.keys(message.purchaseItemKey))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).bool(message.purchaseItemKey[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.InputMessage
 */
export const InputMessage = new InputMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameStateMessage$Type extends MessageType$<GameStateMessage> {
    constructor() {
        super("protocol.GameStateMessage", [
            { no: 1, name: "players", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Player } },
            { no: 2, name: "bullets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Bullet } },
            { no: 3, name: "walls", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Wall } },
            { no: 4, name: "enemies", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Enemy } },
            { no: 5, name: "bonuses", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Bonus } },
            { no: 7, name: "shops", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Shop } },
            { no: 8, name: "players_shops", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GameStateMessage>): GameStateMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.players = {};
        message.bullets = {};
        message.walls = {};
        message.enemies = {};
        message.bonuses = {};
        message.shops = {};
        message.playersShops = [];
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<GameStateMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameStateMessage): GameStateMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, protocol.Player> players */ 1:
                    this.binaryReadMap1(message.players, reader, options);
                    break;
                case /* map<string, protocol.Bullet> bullets */ 2:
                    this.binaryReadMap2(message.bullets, reader, options);
                    break;
                case /* map<string, protocol.Wall> walls */ 3:
                    this.binaryReadMap3(message.walls, reader, options);
                    break;
                case /* map<string, protocol.Enemy> enemies */ 4:
                    this.binaryReadMap4(message.enemies, reader, options);
                    break;
                case /* map<string, protocol.Bonus> bonuses */ 5:
                    this.binaryReadMap5(message.bonuses, reader, options);
                    break;
                case /* map<string, protocol.Shop> shops */ 7:
                    this.binaryReadMap7(message.shops, reader, options);
                    break;
                case /* repeated string players_shops */ 8:
                    message.playersShops.push(reader.string());
                    break;
                case /* int64 timestamp */ 6:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GameStateMessage["players"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateMessage["players"] | undefined, val: GameStateMessage["players"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Player.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateMessage.players");
            }
        }
        map[key ?? ""] = val ?? Player.create();
    }
    private binaryReadMap2(map: GameStateMessage["bullets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateMessage["bullets"] | undefined, val: GameStateMessage["bullets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Bullet.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateMessage.bullets");
            }
        }
        map[key ?? ""] = val ?? Bullet.create();
    }
    private binaryReadMap3(map: GameStateMessage["walls"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateMessage["walls"] | undefined, val: GameStateMessage["walls"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Wall.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateMessage.walls");
            }
        }
        map[key ?? ""] = val ?? Wall.create();
    }
    private binaryReadMap4(map: GameStateMessage["enemies"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateMessage["enemies"] | undefined, val: GameStateMessage["enemies"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Enemy.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateMessage.enemies");
            }
        }
        map[key ?? ""] = val ?? Enemy.create();
    }
    private binaryReadMap5(map: GameStateMessage["bonuses"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateMessage["bonuses"] | undefined, val: GameStateMessage["bonuses"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Bonus.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateMessage.bonuses");
            }
        }
        map[key ?? ""] = val ?? Bonus.create();
    }
    private binaryReadMap7(map: GameStateMessage["shops"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateMessage["shops"] | undefined, val: GameStateMessage["shops"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Shop.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateMessage.shops");
            }
        }
        map[key ?? ""] = val ?? Shop.create();
    }
    internalBinaryWrite(message: GameStateMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, protocol.Player> players = 1; */
        for (let k of globalThis.Object.keys(message.players)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Player.internalBinaryWrite(message.players[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.Bullet> bullets = 2; */
        for (let k of globalThis.Object.keys(message.bullets)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Bullet.internalBinaryWrite(message.bullets[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.Wall> walls = 3; */
        for (let k of globalThis.Object.keys(message.walls)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Wall.internalBinaryWrite(message.walls[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.Enemy> enemies = 4; */
        for (let k of globalThis.Object.keys(message.enemies)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Enemy.internalBinaryWrite(message.enemies[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.Bonus> bonuses = 5; */
        for (let k of globalThis.Object.keys(message.bonuses)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Bonus.internalBinaryWrite(message.bonuses[k], writer, options);
            writer.join().join();
        }
        /* int64 timestamp = 6; */
        if (message.timestamp !== 0n)
            writer.tag(6, WireType.Varint).int64(message.timestamp);
        /* map<string, protocol.Shop> shops = 7; */
        for (let k of globalThis.Object.keys(message.shops)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Shop.internalBinaryWrite(message.shops[k], writer, options);
            writer.join().join();
        }
        /* repeated string players_shops = 8; */
        for (let i = 0; i < message.playersShops.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.playersShops[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.GameStateMessage
 */
export const GameStateMessage = new GameStateMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameStateDeltaMessage$Type extends MessageType$<GameStateDeltaMessage> {
    constructor() {
        super("protocol.GameStateDeltaMessage", [
            { no: 1, name: "updated_players", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Player } },
            { no: 2, name: "removed_players", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "updated_bullets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Bullet } },
            { no: 4, name: "removed_bullets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Bullet } },
            { no: 5, name: "updated_walls", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Wall } },
            { no: 6, name: "removed_walls", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "updated_enemies", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Enemy } },
            { no: 8, name: "removed_enemies", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "updated_bonuses", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Bonus } },
            { no: 10, name: "removed_bonuses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "updated_shops", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Shop } },
            { no: 13, name: "removed_shops", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "players_shops", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GameStateDeltaMessage>): GameStateDeltaMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updatedPlayers = {};
        message.removedPlayers = [];
        message.updatedBullets = {};
        message.removedBullets = {};
        message.updatedWalls = {};
        message.removedWalls = [];
        message.updatedEnemies = {};
        message.removedEnemies = [];
        message.updatedBonuses = {};
        message.removedBonuses = [];
        message.updatedShops = {};
        message.removedShops = [];
        message.playersShops = [];
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<GameStateDeltaMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameStateDeltaMessage): GameStateDeltaMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, protocol.Player> updated_players */ 1:
                    this.binaryReadMap1(message.updatedPlayers, reader, options);
                    break;
                case /* repeated string removed_players */ 2:
                    message.removedPlayers.push(reader.string());
                    break;
                case /* map<string, protocol.Bullet> updated_bullets */ 3:
                    this.binaryReadMap3(message.updatedBullets, reader, options);
                    break;
                case /* map<string, protocol.Bullet> removed_bullets */ 4:
                    this.binaryReadMap4(message.removedBullets, reader, options);
                    break;
                case /* map<string, protocol.Wall> updated_walls */ 5:
                    this.binaryReadMap5(message.updatedWalls, reader, options);
                    break;
                case /* repeated string removed_walls */ 6:
                    message.removedWalls.push(reader.string());
                    break;
                case /* map<string, protocol.Enemy> updated_enemies */ 7:
                    this.binaryReadMap7(message.updatedEnemies, reader, options);
                    break;
                case /* repeated string removed_enemies */ 8:
                    message.removedEnemies.push(reader.string());
                    break;
                case /* map<string, protocol.Bonus> updated_bonuses */ 9:
                    this.binaryReadMap9(message.updatedBonuses, reader, options);
                    break;
                case /* repeated string removed_bonuses */ 10:
                    message.removedBonuses.push(reader.string());
                    break;
                case /* map<string, protocol.Shop> updated_shops */ 12:
                    this.binaryReadMap12(message.updatedShops, reader, options);
                    break;
                case /* repeated string removed_shops */ 13:
                    message.removedShops.push(reader.string());
                    break;
                case /* repeated string players_shops */ 14:
                    message.playersShops.push(reader.string());
                    break;
                case /* int64 timestamp */ 11:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GameStateDeltaMessage["updatedPlayers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["updatedPlayers"] | undefined, val: GameStateDeltaMessage["updatedPlayers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Player.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.updated_players");
            }
        }
        map[key ?? ""] = val ?? Player.create();
    }
    private binaryReadMap3(map: GameStateDeltaMessage["updatedBullets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["updatedBullets"] | undefined, val: GameStateDeltaMessage["updatedBullets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Bullet.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.updated_bullets");
            }
        }
        map[key ?? ""] = val ?? Bullet.create();
    }
    private binaryReadMap4(map: GameStateDeltaMessage["removedBullets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["removedBullets"] | undefined, val: GameStateDeltaMessage["removedBullets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Bullet.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.removed_bullets");
            }
        }
        map[key ?? ""] = val ?? Bullet.create();
    }
    private binaryReadMap5(map: GameStateDeltaMessage["updatedWalls"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["updatedWalls"] | undefined, val: GameStateDeltaMessage["updatedWalls"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Wall.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.updated_walls");
            }
        }
        map[key ?? ""] = val ?? Wall.create();
    }
    private binaryReadMap7(map: GameStateDeltaMessage["updatedEnemies"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["updatedEnemies"] | undefined, val: GameStateDeltaMessage["updatedEnemies"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Enemy.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.updated_enemies");
            }
        }
        map[key ?? ""] = val ?? Enemy.create();
    }
    private binaryReadMap9(map: GameStateDeltaMessage["updatedBonuses"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["updatedBonuses"] | undefined, val: GameStateDeltaMessage["updatedBonuses"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Bonus.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.updated_bonuses");
            }
        }
        map[key ?? ""] = val ?? Bonus.create();
    }
    private binaryReadMap12(map: GameStateDeltaMessage["updatedShops"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["updatedShops"] | undefined, val: GameStateDeltaMessage["updatedShops"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Shop.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.updated_shops");
            }
        }
        map[key ?? ""] = val ?? Shop.create();
    }
    internalBinaryWrite(message: GameStateDeltaMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, protocol.Player> updated_players = 1; */
        for (let k of globalThis.Object.keys(message.updatedPlayers)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Player.internalBinaryWrite(message.updatedPlayers[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_players = 2; */
        for (let i = 0; i < message.removedPlayers.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.removedPlayers[i]);
        /* map<string, protocol.Bullet> updated_bullets = 3; */
        for (let k of globalThis.Object.keys(message.updatedBullets)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Bullet.internalBinaryWrite(message.updatedBullets[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.Bullet> removed_bullets = 4; */
        for (let k of globalThis.Object.keys(message.removedBullets)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Bullet.internalBinaryWrite(message.removedBullets[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.Wall> updated_walls = 5; */
        for (let k of globalThis.Object.keys(message.updatedWalls)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Wall.internalBinaryWrite(message.updatedWalls[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_walls = 6; */
        for (let i = 0; i < message.removedWalls.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.removedWalls[i]);
        /* map<string, protocol.Enemy> updated_enemies = 7; */
        for (let k of globalThis.Object.keys(message.updatedEnemies)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Enemy.internalBinaryWrite(message.updatedEnemies[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_enemies = 8; */
        for (let i = 0; i < message.removedEnemies.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.removedEnemies[i]);
        /* map<string, protocol.Bonus> updated_bonuses = 9; */
        for (let k of globalThis.Object.keys(message.updatedBonuses)) {
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Bonus.internalBinaryWrite(message.updatedBonuses[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_bonuses = 10; */
        for (let i = 0; i < message.removedBonuses.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.removedBonuses[i]);
        /* int64 timestamp = 11; */
        if (message.timestamp !== 0n)
            writer.tag(11, WireType.Varint).int64(message.timestamp);
        /* map<string, protocol.Shop> updated_shops = 12; */
        for (let k of globalThis.Object.keys(message.updatedShops)) {
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Shop.internalBinaryWrite(message.updatedShops[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_shops = 13; */
        for (let i = 0; i < message.removedShops.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.removedShops[i]);
        /* repeated string players_shops = 14; */
        for (let i = 0; i < message.playersShops.length; i++)
            writer.tag(14, WireType.LengthDelimited).string(message.playersShops[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.GameStateDeltaMessage
 */
export const GameStateDeltaMessage = new GameStateDeltaMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerJoinMessage$Type extends MessageType$<PlayerJoinMessage> {
    constructor() {
        super("protocol.PlayerJoinMessage", [
            { no: 1, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<PlayerJoinMessage>): PlayerJoinMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PlayerJoinMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerJoinMessage): PlayerJoinMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protocol.Player player */ 1:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerJoinMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protocol.Player player = 1; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.PlayerJoinMessage
 */
export const PlayerJoinMessage = new PlayerJoinMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerLeaveMessage$Type extends MessageType$<PlayerLeaveMessage> {
    constructor() {
        super("protocol.PlayerLeaveMessage", [
            { no: 1, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerLeaveMessage>): PlayerLeaveMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerId = "";
        if (value !== undefined)
            reflectionMergePartial<PlayerLeaveMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerLeaveMessage): PlayerLeaveMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_id */ 1:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerLeaveMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_id = 1; */
        if (message.playerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.PlayerLeaveMessage
 */
export const PlayerLeaveMessage = new PlayerLeaveMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerRespawnMessage$Type extends MessageType$<PlayerRespawnMessage> {
    constructor() {
        super("protocol.PlayerRespawnMessage", []);
    }
    create(value?: PartialMessage<PlayerRespawnMessage>): PlayerRespawnMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PlayerRespawnMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerRespawnMessage): PlayerRespawnMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerRespawnMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.PlayerRespawnMessage
 */
export const PlayerRespawnMessage = new PlayerRespawnMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorMessage$Type extends MessageType$<ErrorMessage> {
    constructor() {
        super("protocol.ErrorMessage", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ErrorMessage>): ErrorMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ErrorMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorMessage): ErrorMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.ErrorMessage
 */
export const ErrorMessage = new ErrorMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameMessage$Type extends MessageType$<GameMessage> {
    constructor() {
        super("protocol.GameMessage", [
            { no: 1, name: "type", kind: "enum", T: () => ["protocol.MessageType", MessageType] },
            { no: 3, name: "input", kind: "message", oneof: "payload", T: () => InputMessage },
            { no: 5, name: "game_state", kind: "message", oneof: "payload", T: () => GameStateMessage },
            { no: 11, name: "game_state_delta", kind: "message", oneof: "payload", T: () => GameStateDeltaMessage },
            { no: 6, name: "player_join", kind: "message", oneof: "payload", T: () => PlayerJoinMessage },
            { no: 7, name: "player_leave", kind: "message", oneof: "payload", T: () => PlayerLeaveMessage },
            { no: 8, name: "player_respawn", kind: "message", oneof: "payload", T: () => PlayerRespawnMessage },
            { no: 10, name: "error", kind: "message", oneof: "payload", T: () => ErrorMessage }
        ]);
    }
    create(value?: PartialMessage<GameMessage>): GameMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<GameMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameMessage): GameMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protocol.MessageType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* protocol.InputMessage input */ 3:
                    message.payload = {
                        oneofKind: "input",
                        input: InputMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).input)
                    };
                    break;
                case /* protocol.GameStateMessage game_state */ 5:
                    message.payload = {
                        oneofKind: "gameState",
                        gameState: GameStateMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).gameState)
                    };
                    break;
                case /* protocol.GameStateDeltaMessage game_state_delta */ 11:
                    message.payload = {
                        oneofKind: "gameStateDelta",
                        gameStateDelta: GameStateDeltaMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).gameStateDelta)
                    };
                    break;
                case /* protocol.PlayerJoinMessage player_join */ 6:
                    message.payload = {
                        oneofKind: "playerJoin",
                        playerJoin: PlayerJoinMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).playerJoin)
                    };
                    break;
                case /* protocol.PlayerLeaveMessage player_leave */ 7:
                    message.payload = {
                        oneofKind: "playerLeave",
                        playerLeave: PlayerLeaveMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).playerLeave)
                    };
                    break;
                case /* protocol.PlayerRespawnMessage player_respawn */ 8:
                    message.payload = {
                        oneofKind: "playerRespawn",
                        playerRespawn: PlayerRespawnMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).playerRespawn)
                    };
                    break;
                case /* protocol.ErrorMessage error */ 10:
                    message.payload = {
                        oneofKind: "error",
                        error: ErrorMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protocol.MessageType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* protocol.InputMessage input = 3; */
        if (message.payload.oneofKind === "input")
            InputMessage.internalBinaryWrite(message.payload.input, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* protocol.GameStateMessage game_state = 5; */
        if (message.payload.oneofKind === "gameState")
            GameStateMessage.internalBinaryWrite(message.payload.gameState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* protocol.PlayerJoinMessage player_join = 6; */
        if (message.payload.oneofKind === "playerJoin")
            PlayerJoinMessage.internalBinaryWrite(message.payload.playerJoin, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* protocol.PlayerLeaveMessage player_leave = 7; */
        if (message.payload.oneofKind === "playerLeave")
            PlayerLeaveMessage.internalBinaryWrite(message.payload.playerLeave, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* protocol.PlayerRespawnMessage player_respawn = 8; */
        if (message.payload.oneofKind === "playerRespawn")
            PlayerRespawnMessage.internalBinaryWrite(message.payload.playerRespawn, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* protocol.ErrorMessage error = 10; */
        if (message.payload.oneofKind === "error")
            ErrorMessage.internalBinaryWrite(message.payload.error, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* protocol.GameStateDeltaMessage game_state_delta = 11; */
        if (message.payload.oneofKind === "gameStateDelta")
            GameStateDeltaMessage.internalBinaryWrite(message.payload.gameStateDelta, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.GameMessage
 */
export const GameMessage = new GameMessage$Type();
