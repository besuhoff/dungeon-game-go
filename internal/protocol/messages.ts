// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "messages.proto" (package "protocol", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType as MessageType$ } from "@protobuf-ts/runtime";
/**
 * Common structures
 *
 * @generated from protobuf message protocol.Vector2
 */
export interface Vector2 {
    /**
     * @generated from protobuf field: double x = 1
     */
    x: number;
    /**
     * @generated from protobuf field: double y = 2
     */
    y: number;
}
/**
 * @generated from protobuf message protocol.Player
 */
export interface Player {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string username = 2
     */
    username: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 3
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: protocol.Vector2 velocity = 4
     */
    velocity?: Vector2;
    /**
     * @generated from protobuf field: int32 lives = 5
     */
    lives: number;
    /**
     * @generated from protobuf field: int32 score = 6
     */
    score: number;
    /**
     * @generated from protobuf field: double money = 7
     */
    money: number;
    /**
     * @generated from protobuf field: int32 kills = 8
     */
    kills: number;
    /**
     * @generated from protobuf field: double rotation = 9
     */
    rotation: number;
    /**
     * @generated from protobuf field: int32 bullets_left = 10
     */
    bulletsLeft: number;
    /**
     * @generated from protobuf field: double night_vision_timer = 11
     */
    nightVisionTimer: number;
    /**
     * @generated from protobuf field: bool is_alive = 12
     */
    isAlive: boolean;
}
/**
 * @generated from protobuf message protocol.Bullet
 */
export interface Bullet {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: protocol.Vector2 velocity = 3
     */
    velocity?: Vector2;
    /**
     * @generated from protobuf field: string owner_id = 4
     */
    ownerId: string;
    /**
     * @generated from protobuf field: int32 damage = 5
     */
    damage: number;
}
/**
 * @generated from protobuf message protocol.Wall
 */
export interface Wall {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: double width = 3
     */
    width: number;
    /**
     * @generated from protobuf field: double height = 4
     */
    height: number;
    /**
     * @generated from protobuf field: string orientation = 5
     */
    orientation: string;
}
/**
 * @generated from protobuf message protocol.Enemy
 */
export interface Enemy {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: double rotation = 3
     */
    rotation: number;
    /**
     * @generated from protobuf field: int32 lives = 4
     */
    lives: number;
    /**
     * @generated from protobuf field: string wall_id = 5
     */
    wallId: string;
    /**
     * @generated from protobuf field: bool is_dead = 6
     */
    isDead: boolean;
}
/**
 * @generated from protobuf message protocol.Bonus
 */
export interface Bonus {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: string type = 3
     */
    type: string;
}
/**
 * Client -> Server messages
 *
 * @generated from protobuf message protocol.ConnectMessage
 */
export interface ConnectMessage {
    /**
     * @generated from protobuf field: string username = 1
     */
    username: string;
}
/**
 * @generated from protobuf message protocol.InputMessage
 */
export interface InputMessage {
    /**
     * @generated from protobuf field: bool forward = 1
     */
    forward: boolean;
    /**
     * @generated from protobuf field: bool backward = 2
     */
    backward: boolean;
    /**
     * @generated from protobuf field: bool left = 3
     */
    left: boolean;
    /**
     * @generated from protobuf field: bool right = 4
     */
    right: boolean;
}
/**
 * @generated from protobuf message protocol.ShootMessage
 */
export interface ShootMessage {
    /**
     * @generated from protobuf field: double direction = 1
     */
    direction: number;
}
/**
 * Server -> Client messages
 *
 * @generated from protobuf message protocol.GameState
 */
export interface GameState {
    /**
     * @generated from protobuf field: map<string, protocol.Player> players = 1
     */
    players: {
        [key: string]: Player;
    };
    /**
     * @generated from protobuf field: map<string, protocol.Bullet> bullets = 2
     */
    bullets: {
        [key: string]: Bullet;
    };
    /**
     * @generated from protobuf field: map<string, protocol.Wall> walls = 3
     */
    walls: {
        [key: string]: Wall;
    };
    /**
     * @generated from protobuf field: map<string, protocol.Enemy> enemies = 4
     */
    enemies: {
        [key: string]: Enemy;
    };
    /**
     * @generated from protobuf field: map<string, protocol.Bonus> bonuses = 5
     */
    bonuses: {
        [key: string]: Bonus;
    };
    /**
     * @generated from protobuf field: int64 timestamp = 6
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message protocol.GameStateDelta
 */
export interface GameStateDelta {
    /**
     * @generated from protobuf field: map<string, protocol.Player> updated_players = 1
     */
    updatedPlayers: {
        [key: string]: Player;
    };
    /**
     * @generated from protobuf field: repeated string removed_players = 2
     */
    removedPlayers: string[];
    /**
     * @generated from protobuf field: map<string, protocol.Bullet> updated_bullets = 3
     */
    updatedBullets: {
        [key: string]: Bullet;
    };
    /**
     * @generated from protobuf field: repeated string removed_bullets = 4
     */
    removedBullets: string[];
    /**
     * @generated from protobuf field: map<string, protocol.Wall> updated_walls = 5
     */
    updatedWalls: {
        [key: string]: Wall;
    };
    /**
     * @generated from protobuf field: repeated string removed_walls = 6
     */
    removedWalls: string[];
    /**
     * @generated from protobuf field: map<string, protocol.Enemy> updated_enemies = 7
     */
    updatedEnemies: {
        [key: string]: Enemy;
    };
    /**
     * @generated from protobuf field: repeated string removed_enemies = 8
     */
    removedEnemies: string[];
    /**
     * @generated from protobuf field: map<string, protocol.Bonus> updated_bonuses = 9
     */
    updatedBonuses: {
        [key: string]: Bonus;
    };
    /**
     * @generated from protobuf field: repeated string removed_bonuses = 10
     */
    removedBonuses: string[];
    /**
     * @generated from protobuf field: int64 timestamp = 11
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message protocol.PlayerJoinMessage
 */
export interface PlayerJoinMessage {
    /**
     * @generated from protobuf field: protocol.Player player = 1
     */
    player?: Player;
}
/**
 * @generated from protobuf message protocol.PlayerLeaveMessage
 */
export interface PlayerLeaveMessage {
    /**
     * @generated from protobuf field: string player_id = 1
     */
    playerId: string;
}
/**
 * @generated from protobuf message protocol.PlayerHitMessage
 */
export interface PlayerHitMessage {
    /**
     * @generated from protobuf field: string player_id = 1
     */
    playerId: string;
    /**
     * @generated from protobuf field: string attacker_id = 2
     */
    attackerId: string;
    /**
     * @generated from protobuf field: int32 damage = 3
     */
    damage: number;
    /**
     * @generated from protobuf field: int32 new_lives = 4
     */
    newLives: number;
}
/**
 * @generated from protobuf message protocol.PlayerDeathMessage
 */
export interface PlayerDeathMessage {
    /**
     * @generated from protobuf field: string player_id = 1
     */
    playerId: string;
    /**
     * @generated from protobuf field: string killer_id = 2
     */
    killerId: string;
}
/**
 * @generated from protobuf message protocol.ErrorMessage
 */
export interface ErrorMessage {
    /**
     * @generated from protobuf field: string message = 1
     */
    message: string;
}
/**
 * Wrapper message
 *
 * @generated from protobuf message protocol.GameMessage
 */
export interface GameMessage {
    /**
     * @generated from protobuf field: protocol.MessageType type = 1
     */
    type: MessageType;
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "connect";
        /**
         * @generated from protobuf field: protocol.ConnectMessage connect = 2
         */
        connect: ConnectMessage;
    } | {
        oneofKind: "input";
        /**
         * @generated from protobuf field: protocol.InputMessage input = 3
         */
        input: InputMessage;
    } | {
        oneofKind: "shoot";
        /**
         * @generated from protobuf field: protocol.ShootMessage shoot = 4
         */
        shoot: ShootMessage;
    } | {
        oneofKind: "gameState";
        /**
         * @generated from protobuf field: protocol.GameState game_state = 5
         */
        gameState: GameState;
    } | {
        oneofKind: "gameStateDelta";
        /**
         * @generated from protobuf field: protocol.GameStateDelta game_state_delta = 11
         */
        gameStateDelta: GameStateDelta;
    } | {
        oneofKind: "playerJoin";
        /**
         * @generated from protobuf field: protocol.PlayerJoinMessage player_join = 6
         */
        playerJoin: PlayerJoinMessage;
    } | {
        oneofKind: "playerLeave";
        /**
         * @generated from protobuf field: protocol.PlayerLeaveMessage player_leave = 7
         */
        playerLeave: PlayerLeaveMessage;
    } | {
        oneofKind: "playerHit";
        /**
         * @generated from protobuf field: protocol.PlayerHitMessage player_hit = 8
         */
        playerHit: PlayerHitMessage;
    } | {
        oneofKind: "playerDeath";
        /**
         * @generated from protobuf field: protocol.PlayerDeathMessage player_death = 9
         */
        playerDeath: PlayerDeathMessage;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: protocol.ErrorMessage error = 10
         */
        error: ErrorMessage;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Message types
 *
 * @generated from protobuf enum protocol.MessageType
 */
export enum MessageType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: CONNECT = 1;
     */
    CONNECT = 1,
    /**
     * @generated from protobuf enum value: INPUT = 2;
     */
    INPUT = 2,
    /**
     * @generated from protobuf enum value: SHOOT = 3;
     */
    SHOOT = 3,
    /**
     * @generated from protobuf enum value: DISCONNECT = 4;
     */
    DISCONNECT = 4,
    /**
     * @generated from protobuf enum value: GAME_STATE = 5;
     */
    GAME_STATE = 5,
    /**
     * @generated from protobuf enum value: GAME_STATE_DELTA = 11;
     */
    GAME_STATE_DELTA = 11,
    /**
     * @generated from protobuf enum value: PLAYER_JOIN = 6;
     */
    PLAYER_JOIN = 6,
    /**
     * @generated from protobuf enum value: PLAYER_LEAVE = 7;
     */
    PLAYER_LEAVE = 7,
    /**
     * @generated from protobuf enum value: PLAYER_HIT = 8;
     */
    PLAYER_HIT = 8,
    /**
     * @generated from protobuf enum value: PLAYER_DEATH = 9;
     */
    PLAYER_DEATH = 9,
    /**
     * @generated from protobuf enum value: ERROR = 10;
     */
    ERROR = 10
}
// @generated message type with reflection information, may provide speed optimized methods
class Vector2$Type extends MessageType$<Vector2> {
    constructor() {
        super("protocol.Vector2", [
            { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Vector2>): Vector2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<Vector2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vector2): Vector2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double x */ 1:
                    message.x = reader.double();
                    break;
                case /* double y */ 2:
                    message.y = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vector2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit64).double(message.x);
        /* double y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit64).double(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Vector2
 */
export const Vector2 = new Vector2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player$Type extends MessageType$<Player> {
    constructor() {
        super("protocol.Player", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "position", kind: "message", T: () => Vector2 },
            { no: 4, name: "velocity", kind: "message", T: () => Vector2 },
            { no: 5, name: "lives", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "money", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "kills", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "rotation", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "bullets_left", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "night_vision_timer", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "is_alive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Player>): Player {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.username = "";
        message.lives = 0;
        message.score = 0;
        message.money = 0;
        message.kills = 0;
        message.rotation = 0;
        message.bulletsLeft = 0;
        message.nightVisionTimer = 0;
        message.isAlive = false;
        if (value !== undefined)
            reflectionMergePartial<Player>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Player): Player {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string username */ 2:
                    message.username = reader.string();
                    break;
                case /* protocol.Vector2 position */ 3:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* protocol.Vector2 velocity */ 4:
                    message.velocity = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                case /* int32 lives */ 5:
                    message.lives = reader.int32();
                    break;
                case /* int32 score */ 6:
                    message.score = reader.int32();
                    break;
                case /* double money */ 7:
                    message.money = reader.double();
                    break;
                case /* int32 kills */ 8:
                    message.kills = reader.int32();
                    break;
                case /* double rotation */ 9:
                    message.rotation = reader.double();
                    break;
                case /* int32 bullets_left */ 10:
                    message.bulletsLeft = reader.int32();
                    break;
                case /* double night_vision_timer */ 11:
                    message.nightVisionTimer = reader.double();
                    break;
                case /* bool is_alive */ 12:
                    message.isAlive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Player, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string username = 2; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* protocol.Vector2 position = 3; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* protocol.Vector2 velocity = 4; */
        if (message.velocity)
            Vector2.internalBinaryWrite(message.velocity, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int32 lives = 5; */
        if (message.lives !== 0)
            writer.tag(5, WireType.Varint).int32(message.lives);
        /* int32 score = 6; */
        if (message.score !== 0)
            writer.tag(6, WireType.Varint).int32(message.score);
        /* double money = 7; */
        if (message.money !== 0)
            writer.tag(7, WireType.Bit64).double(message.money);
        /* int32 kills = 8; */
        if (message.kills !== 0)
            writer.tag(8, WireType.Varint).int32(message.kills);
        /* double rotation = 9; */
        if (message.rotation !== 0)
            writer.tag(9, WireType.Bit64).double(message.rotation);
        /* int32 bullets_left = 10; */
        if (message.bulletsLeft !== 0)
            writer.tag(10, WireType.Varint).int32(message.bulletsLeft);
        /* double night_vision_timer = 11; */
        if (message.nightVisionTimer !== 0)
            writer.tag(11, WireType.Bit64).double(message.nightVisionTimer);
        /* bool is_alive = 12; */
        if (message.isAlive !== false)
            writer.tag(12, WireType.Varint).bool(message.isAlive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Player
 */
export const Player = new Player$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bullet$Type extends MessageType$<Bullet> {
    constructor() {
        super("protocol.Bullet", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "velocity", kind: "message", T: () => Vector2 },
            { no: 4, name: "owner_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "damage", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Bullet>): Bullet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.ownerId = "";
        message.damage = 0;
        if (value !== undefined)
            reflectionMergePartial<Bullet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bullet): Bullet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* protocol.Vector2 velocity */ 3:
                    message.velocity = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                case /* string owner_id */ 4:
                    message.ownerId = reader.string();
                    break;
                case /* int32 damage */ 5:
                    message.damage = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bullet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* protocol.Vector2 velocity = 3; */
        if (message.velocity)
            Vector2.internalBinaryWrite(message.velocity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string owner_id = 4; */
        if (message.ownerId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ownerId);
        /* int32 damage = 5; */
        if (message.damage !== 0)
            writer.tag(5, WireType.Varint).int32(message.damage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Bullet
 */
export const Bullet = new Bullet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Wall$Type extends MessageType$<Wall> {
    constructor() {
        super("protocol.Wall", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "width", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "height", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "orientation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Wall>): Wall {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.width = 0;
        message.height = 0;
        message.orientation = "";
        if (value !== undefined)
            reflectionMergePartial<Wall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Wall): Wall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* double width */ 3:
                    message.width = reader.double();
                    break;
                case /* double height */ 4:
                    message.height = reader.double();
                    break;
                case /* string orientation */ 5:
                    message.orientation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Wall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* double width = 3; */
        if (message.width !== 0)
            writer.tag(3, WireType.Bit64).double(message.width);
        /* double height = 4; */
        if (message.height !== 0)
            writer.tag(4, WireType.Bit64).double(message.height);
        /* string orientation = 5; */
        if (message.orientation !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.orientation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Wall
 */
export const Wall = new Wall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Enemy$Type extends MessageType$<Enemy> {
    constructor() {
        super("protocol.Enemy", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "rotation", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "lives", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "wall_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "is_dead", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Enemy>): Enemy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.rotation = 0;
        message.lives = 0;
        message.wallId = "";
        message.isDead = false;
        if (value !== undefined)
            reflectionMergePartial<Enemy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Enemy): Enemy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* double rotation */ 3:
                    message.rotation = reader.double();
                    break;
                case /* int32 lives */ 4:
                    message.lives = reader.int32();
                    break;
                case /* string wall_id */ 5:
                    message.wallId = reader.string();
                    break;
                case /* bool is_dead */ 6:
                    message.isDead = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Enemy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* double rotation = 3; */
        if (message.rotation !== 0)
            writer.tag(3, WireType.Bit64).double(message.rotation);
        /* int32 lives = 4; */
        if (message.lives !== 0)
            writer.tag(4, WireType.Varint).int32(message.lives);
        /* string wall_id = 5; */
        if (message.wallId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.wallId);
        /* bool is_dead = 6; */
        if (message.isDead !== false)
            writer.tag(6, WireType.Varint).bool(message.isDead);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Enemy
 */
export const Enemy = new Enemy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bonus$Type extends MessageType$<Bonus> {
    constructor() {
        super("protocol.Bonus", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Bonus>): Bonus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<Bonus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bonus): Bonus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bonus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Bonus
 */
export const Bonus = new Bonus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectMessage$Type extends MessageType$<ConnectMessage> {
    constructor() {
        super("protocol.ConnectMessage", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConnectMessage>): ConnectMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        if (value !== undefined)
            reflectionMergePartial<ConnectMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectMessage): ConnectMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.ConnectMessage
 */
export const ConnectMessage = new ConnectMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InputMessage$Type extends MessageType$<InputMessage> {
    constructor() {
        super("protocol.InputMessage", [
            { no: 1, name: "forward", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "backward", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "left", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "right", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<InputMessage>): InputMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.forward = false;
        message.backward = false;
        message.left = false;
        message.right = false;
        if (value !== undefined)
            reflectionMergePartial<InputMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InputMessage): InputMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool forward */ 1:
                    message.forward = reader.bool();
                    break;
                case /* bool backward */ 2:
                    message.backward = reader.bool();
                    break;
                case /* bool left */ 3:
                    message.left = reader.bool();
                    break;
                case /* bool right */ 4:
                    message.right = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InputMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool forward = 1; */
        if (message.forward !== false)
            writer.tag(1, WireType.Varint).bool(message.forward);
        /* bool backward = 2; */
        if (message.backward !== false)
            writer.tag(2, WireType.Varint).bool(message.backward);
        /* bool left = 3; */
        if (message.left !== false)
            writer.tag(3, WireType.Varint).bool(message.left);
        /* bool right = 4; */
        if (message.right !== false)
            writer.tag(4, WireType.Varint).bool(message.right);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.InputMessage
 */
export const InputMessage = new InputMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShootMessage$Type extends MessageType$<ShootMessage> {
    constructor() {
        super("protocol.ShootMessage", [
            { no: 1, name: "direction", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ShootMessage>): ShootMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.direction = 0;
        if (value !== undefined)
            reflectionMergePartial<ShootMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShootMessage): ShootMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double direction */ 1:
                    message.direction = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShootMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double direction = 1; */
        if (message.direction !== 0)
            writer.tag(1, WireType.Bit64).double(message.direction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.ShootMessage
 */
export const ShootMessage = new ShootMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameState$Type extends MessageType$<GameState> {
    constructor() {
        super("protocol.GameState", [
            { no: 1, name: "players", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Player } },
            { no: 2, name: "bullets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Bullet } },
            { no: 3, name: "walls", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Wall } },
            { no: 4, name: "enemies", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Enemy } },
            { no: 5, name: "bonuses", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Bonus } },
            { no: 6, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GameState>): GameState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.players = {};
        message.bullets = {};
        message.walls = {};
        message.enemies = {};
        message.bonuses = {};
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<GameState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameState): GameState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, protocol.Player> players */ 1:
                    this.binaryReadMap1(message.players, reader, options);
                    break;
                case /* map<string, protocol.Bullet> bullets */ 2:
                    this.binaryReadMap2(message.bullets, reader, options);
                    break;
                case /* map<string, protocol.Wall> walls */ 3:
                    this.binaryReadMap3(message.walls, reader, options);
                    break;
                case /* map<string, protocol.Enemy> enemies */ 4:
                    this.binaryReadMap4(message.enemies, reader, options);
                    break;
                case /* map<string, protocol.Bonus> bonuses */ 5:
                    this.binaryReadMap5(message.bonuses, reader, options);
                    break;
                case /* int64 timestamp */ 6:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GameState["players"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameState["players"] | undefined, val: GameState["players"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Player.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameState.players");
            }
        }
        map[key ?? ""] = val ?? Player.create();
    }
    private binaryReadMap2(map: GameState["bullets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameState["bullets"] | undefined, val: GameState["bullets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Bullet.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameState.bullets");
            }
        }
        map[key ?? ""] = val ?? Bullet.create();
    }
    private binaryReadMap3(map: GameState["walls"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameState["walls"] | undefined, val: GameState["walls"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Wall.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameState.walls");
            }
        }
        map[key ?? ""] = val ?? Wall.create();
    }
    private binaryReadMap4(map: GameState["enemies"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameState["enemies"] | undefined, val: GameState["enemies"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Enemy.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameState.enemies");
            }
        }
        map[key ?? ""] = val ?? Enemy.create();
    }
    private binaryReadMap5(map: GameState["bonuses"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameState["bonuses"] | undefined, val: GameState["bonuses"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Bonus.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameState.bonuses");
            }
        }
        map[key ?? ""] = val ?? Bonus.create();
    }
    internalBinaryWrite(message: GameState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, protocol.Player> players = 1; */
        for (let k of globalThis.Object.keys(message.players)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Player.internalBinaryWrite(message.players[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.Bullet> bullets = 2; */
        for (let k of globalThis.Object.keys(message.bullets)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Bullet.internalBinaryWrite(message.bullets[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.Wall> walls = 3; */
        for (let k of globalThis.Object.keys(message.walls)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Wall.internalBinaryWrite(message.walls[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.Enemy> enemies = 4; */
        for (let k of globalThis.Object.keys(message.enemies)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Enemy.internalBinaryWrite(message.enemies[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.Bonus> bonuses = 5; */
        for (let k of globalThis.Object.keys(message.bonuses)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Bonus.internalBinaryWrite(message.bonuses[k], writer, options);
            writer.join().join();
        }
        /* int64 timestamp = 6; */
        if (message.timestamp !== 0n)
            writer.tag(6, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.GameState
 */
export const GameState = new GameState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameStateDelta$Type extends MessageType$<GameStateDelta> {
    constructor() {
        super("protocol.GameStateDelta", [
            { no: 1, name: "updated_players", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Player } },
            { no: 2, name: "removed_players", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "updated_bullets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Bullet } },
            { no: 4, name: "removed_bullets", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "updated_walls", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Wall } },
            { no: 6, name: "removed_walls", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "updated_enemies", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Enemy } },
            { no: 8, name: "removed_enemies", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "updated_bonuses", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Bonus } },
            { no: 10, name: "removed_bonuses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GameStateDelta>): GameStateDelta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updatedPlayers = {};
        message.removedPlayers = [];
        message.updatedBullets = {};
        message.removedBullets = [];
        message.updatedWalls = {};
        message.removedWalls = [];
        message.updatedEnemies = {};
        message.removedEnemies = [];
        message.updatedBonuses = {};
        message.removedBonuses = [];
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<GameStateDelta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameStateDelta): GameStateDelta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, protocol.Player> updated_players */ 1:
                    this.binaryReadMap1(message.updatedPlayers, reader, options);
                    break;
                case /* repeated string removed_players */ 2:
                    message.removedPlayers.push(reader.string());
                    break;
                case /* map<string, protocol.Bullet> updated_bullets */ 3:
                    this.binaryReadMap3(message.updatedBullets, reader, options);
                    break;
                case /* repeated string removed_bullets */ 4:
                    message.removedBullets.push(reader.string());
                    break;
                case /* map<string, protocol.Wall> updated_walls */ 5:
                    this.binaryReadMap5(message.updatedWalls, reader, options);
                    break;
                case /* repeated string removed_walls */ 6:
                    message.removedWalls.push(reader.string());
                    break;
                case /* map<string, protocol.Enemy> updated_enemies */ 7:
                    this.binaryReadMap7(message.updatedEnemies, reader, options);
                    break;
                case /* repeated string removed_enemies */ 8:
                    message.removedEnemies.push(reader.string());
                    break;
                case /* map<string, protocol.Bonus> updated_bonuses */ 9:
                    this.binaryReadMap9(message.updatedBonuses, reader, options);
                    break;
                case /* repeated string removed_bonuses */ 10:
                    message.removedBonuses.push(reader.string());
                    break;
                case /* int64 timestamp */ 11:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GameStateDelta["updatedPlayers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDelta["updatedPlayers"] | undefined, val: GameStateDelta["updatedPlayers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Player.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDelta.updated_players");
            }
        }
        map[key ?? ""] = val ?? Player.create();
    }
    private binaryReadMap3(map: GameStateDelta["updatedBullets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDelta["updatedBullets"] | undefined, val: GameStateDelta["updatedBullets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Bullet.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDelta.updated_bullets");
            }
        }
        map[key ?? ""] = val ?? Bullet.create();
    }
    private binaryReadMap5(map: GameStateDelta["updatedWalls"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDelta["updatedWalls"] | undefined, val: GameStateDelta["updatedWalls"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Wall.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDelta.updated_walls");
            }
        }
        map[key ?? ""] = val ?? Wall.create();
    }
    private binaryReadMap7(map: GameStateDelta["updatedEnemies"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDelta["updatedEnemies"] | undefined, val: GameStateDelta["updatedEnemies"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Enemy.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDelta.updated_enemies");
            }
        }
        map[key ?? ""] = val ?? Enemy.create();
    }
    private binaryReadMap9(map: GameStateDelta["updatedBonuses"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDelta["updatedBonuses"] | undefined, val: GameStateDelta["updatedBonuses"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Bonus.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDelta.updated_bonuses");
            }
        }
        map[key ?? ""] = val ?? Bonus.create();
    }
    internalBinaryWrite(message: GameStateDelta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, protocol.Player> updated_players = 1; */
        for (let k of globalThis.Object.keys(message.updatedPlayers)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Player.internalBinaryWrite(message.updatedPlayers[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_players = 2; */
        for (let i = 0; i < message.removedPlayers.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.removedPlayers[i]);
        /* map<string, protocol.Bullet> updated_bullets = 3; */
        for (let k of globalThis.Object.keys(message.updatedBullets)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Bullet.internalBinaryWrite(message.updatedBullets[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_bullets = 4; */
        for (let i = 0; i < message.removedBullets.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.removedBullets[i]);
        /* map<string, protocol.Wall> updated_walls = 5; */
        for (let k of globalThis.Object.keys(message.updatedWalls)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Wall.internalBinaryWrite(message.updatedWalls[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_walls = 6; */
        for (let i = 0; i < message.removedWalls.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.removedWalls[i]);
        /* map<string, protocol.Enemy> updated_enemies = 7; */
        for (let k of globalThis.Object.keys(message.updatedEnemies)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Enemy.internalBinaryWrite(message.updatedEnemies[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_enemies = 8; */
        for (let i = 0; i < message.removedEnemies.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.removedEnemies[i]);
        /* map<string, protocol.Bonus> updated_bonuses = 9; */
        for (let k of globalThis.Object.keys(message.updatedBonuses)) {
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Bonus.internalBinaryWrite(message.updatedBonuses[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_bonuses = 10; */
        for (let i = 0; i < message.removedBonuses.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.removedBonuses[i]);
        /* int64 timestamp = 11; */
        if (message.timestamp !== 0n)
            writer.tag(11, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.GameStateDelta
 */
export const GameStateDelta = new GameStateDelta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerJoinMessage$Type extends MessageType$<PlayerJoinMessage> {
    constructor() {
        super("protocol.PlayerJoinMessage", [
            { no: 1, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<PlayerJoinMessage>): PlayerJoinMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PlayerJoinMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerJoinMessage): PlayerJoinMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protocol.Player player */ 1:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerJoinMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protocol.Player player = 1; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.PlayerJoinMessage
 */
export const PlayerJoinMessage = new PlayerJoinMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerLeaveMessage$Type extends MessageType$<PlayerLeaveMessage> {
    constructor() {
        super("protocol.PlayerLeaveMessage", [
            { no: 1, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerLeaveMessage>): PlayerLeaveMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerId = "";
        if (value !== undefined)
            reflectionMergePartial<PlayerLeaveMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerLeaveMessage): PlayerLeaveMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_id */ 1:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerLeaveMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_id = 1; */
        if (message.playerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.PlayerLeaveMessage
 */
export const PlayerLeaveMessage = new PlayerLeaveMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerHitMessage$Type extends MessageType$<PlayerHitMessage> {
    constructor() {
        super("protocol.PlayerHitMessage", [
            { no: 1, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attacker_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "damage", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "new_lives", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerHitMessage>): PlayerHitMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerId = "";
        message.attackerId = "";
        message.damage = 0;
        message.newLives = 0;
        if (value !== undefined)
            reflectionMergePartial<PlayerHitMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerHitMessage): PlayerHitMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_id */ 1:
                    message.playerId = reader.string();
                    break;
                case /* string attacker_id */ 2:
                    message.attackerId = reader.string();
                    break;
                case /* int32 damage */ 3:
                    message.damage = reader.int32();
                    break;
                case /* int32 new_lives */ 4:
                    message.newLives = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerHitMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_id = 1; */
        if (message.playerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerId);
        /* string attacker_id = 2; */
        if (message.attackerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.attackerId);
        /* int32 damage = 3; */
        if (message.damage !== 0)
            writer.tag(3, WireType.Varint).int32(message.damage);
        /* int32 new_lives = 4; */
        if (message.newLives !== 0)
            writer.tag(4, WireType.Varint).int32(message.newLives);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.PlayerHitMessage
 */
export const PlayerHitMessage = new PlayerHitMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerDeathMessage$Type extends MessageType$<PlayerDeathMessage> {
    constructor() {
        super("protocol.PlayerDeathMessage", [
            { no: 1, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "killer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerDeathMessage>): PlayerDeathMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerId = "";
        message.killerId = "";
        if (value !== undefined)
            reflectionMergePartial<PlayerDeathMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerDeathMessage): PlayerDeathMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_id */ 1:
                    message.playerId = reader.string();
                    break;
                case /* string killer_id */ 2:
                    message.killerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerDeathMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_id = 1; */
        if (message.playerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerId);
        /* string killer_id = 2; */
        if (message.killerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.killerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.PlayerDeathMessage
 */
export const PlayerDeathMessage = new PlayerDeathMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorMessage$Type extends MessageType$<ErrorMessage> {
    constructor() {
        super("protocol.ErrorMessage", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ErrorMessage>): ErrorMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ErrorMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorMessage): ErrorMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.ErrorMessage
 */
export const ErrorMessage = new ErrorMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameMessage$Type extends MessageType$<GameMessage> {
    constructor() {
        super("protocol.GameMessage", [
            { no: 1, name: "type", kind: "enum", T: () => ["protocol.MessageType", MessageType] },
            { no: 2, name: "connect", kind: "message", oneof: "payload", T: () => ConnectMessage },
            { no: 3, name: "input", kind: "message", oneof: "payload", T: () => InputMessage },
            { no: 4, name: "shoot", kind: "message", oneof: "payload", T: () => ShootMessage },
            { no: 5, name: "game_state", kind: "message", oneof: "payload", T: () => GameState },
            { no: 11, name: "game_state_delta", kind: "message", oneof: "payload", T: () => GameStateDelta },
            { no: 6, name: "player_join", kind: "message", oneof: "payload", T: () => PlayerJoinMessage },
            { no: 7, name: "player_leave", kind: "message", oneof: "payload", T: () => PlayerLeaveMessage },
            { no: 8, name: "player_hit", kind: "message", oneof: "payload", T: () => PlayerHitMessage },
            { no: 9, name: "player_death", kind: "message", oneof: "payload", T: () => PlayerDeathMessage },
            { no: 10, name: "error", kind: "message", oneof: "payload", T: () => ErrorMessage }
        ]);
    }
    create(value?: PartialMessage<GameMessage>): GameMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<GameMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameMessage): GameMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protocol.MessageType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* protocol.ConnectMessage connect */ 2:
                    message.payload = {
                        oneofKind: "connect",
                        connect: ConnectMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).connect)
                    };
                    break;
                case /* protocol.InputMessage input */ 3:
                    message.payload = {
                        oneofKind: "input",
                        input: InputMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).input)
                    };
                    break;
                case /* protocol.ShootMessage shoot */ 4:
                    message.payload = {
                        oneofKind: "shoot",
                        shoot: ShootMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).shoot)
                    };
                    break;
                case /* protocol.GameState game_state */ 5:
                    message.payload = {
                        oneofKind: "gameState",
                        gameState: GameState.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).gameState)
                    };
                    break;
                case /* protocol.GameStateDelta game_state_delta */ 11:
                    message.payload = {
                        oneofKind: "gameStateDelta",
                        gameStateDelta: GameStateDelta.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).gameStateDelta)
                    };
                    break;
                case /* protocol.PlayerJoinMessage player_join */ 6:
                    message.payload = {
                        oneofKind: "playerJoin",
                        playerJoin: PlayerJoinMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).playerJoin)
                    };
                    break;
                case /* protocol.PlayerLeaveMessage player_leave */ 7:
                    message.payload = {
                        oneofKind: "playerLeave",
                        playerLeave: PlayerLeaveMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).playerLeave)
                    };
                    break;
                case /* protocol.PlayerHitMessage player_hit */ 8:
                    message.payload = {
                        oneofKind: "playerHit",
                        playerHit: PlayerHitMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).playerHit)
                    };
                    break;
                case /* protocol.PlayerDeathMessage player_death */ 9:
                    message.payload = {
                        oneofKind: "playerDeath",
                        playerDeath: PlayerDeathMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).playerDeath)
                    };
                    break;
                case /* protocol.ErrorMessage error */ 10:
                    message.payload = {
                        oneofKind: "error",
                        error: ErrorMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protocol.MessageType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* protocol.ConnectMessage connect = 2; */
        if (message.payload.oneofKind === "connect")
            ConnectMessage.internalBinaryWrite(message.payload.connect, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* protocol.InputMessage input = 3; */
        if (message.payload.oneofKind === "input")
            InputMessage.internalBinaryWrite(message.payload.input, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* protocol.ShootMessage shoot = 4; */
        if (message.payload.oneofKind === "shoot")
            ShootMessage.internalBinaryWrite(message.payload.shoot, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* protocol.GameState game_state = 5; */
        if (message.payload.oneofKind === "gameState")
            GameState.internalBinaryWrite(message.payload.gameState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* protocol.PlayerJoinMessage player_join = 6; */
        if (message.payload.oneofKind === "playerJoin")
            PlayerJoinMessage.internalBinaryWrite(message.payload.playerJoin, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* protocol.PlayerLeaveMessage player_leave = 7; */
        if (message.payload.oneofKind === "playerLeave")
            PlayerLeaveMessage.internalBinaryWrite(message.payload.playerLeave, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* protocol.PlayerHitMessage player_hit = 8; */
        if (message.payload.oneofKind === "playerHit")
            PlayerHitMessage.internalBinaryWrite(message.payload.playerHit, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* protocol.PlayerDeathMessage player_death = 9; */
        if (message.payload.oneofKind === "playerDeath")
            PlayerDeathMessage.internalBinaryWrite(message.payload.playerDeath, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* protocol.ErrorMessage error = 10; */
        if (message.payload.oneofKind === "error")
            ErrorMessage.internalBinaryWrite(message.payload.error, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* protocol.GameStateDelta game_state_delta = 11; */
        if (message.payload.oneofKind === "gameStateDelta")
            GameStateDelta.internalBinaryWrite(message.payload.gameStateDelta, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.GameMessage
 */
export const GameMessage = new GameMessage$Type();
