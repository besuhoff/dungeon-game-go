// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "messages.proto" (package "protocol", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType as MessageType$ } from "@protobuf-ts/runtime";
/**
 * Common structures
 *
 * @generated from protobuf message protocol.Vector2
 */
export interface Vector2 {
    /**
     * @generated from protobuf field: double x = 1
     */
    x: number;
    /**
     * @generated from protobuf field: double y = 2
     */
    y: number;
}
/**
 * @generated from protobuf message protocol.InventoryItem
 */
export interface InventoryItem {
    /**
     * @generated from protobuf field: int32 type = 1
     */
    type: number;
    /**
     * @generated from protobuf field: int32 quantity = 2
     */
    quantity: number;
}
/**
 * @generated from protobuf message protocol.Player
 */
export interface Player {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string username = 2
     */
    username: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 3
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: protocol.Vector2 velocity = 4
     */
    velocity?: Vector2;
    /**
     * @generated from protobuf field: float lives = 5
     */
    lives: number;
    /**
     * @generated from protobuf field: double invulnerable_timer = 13
     */
    invulnerableTimer: number;
    /**
     * @generated from protobuf field: int32 score = 6
     */
    score: number;
    /**
     * @generated from protobuf field: int32 money = 7
     */
    money: number;
    /**
     * @generated from protobuf field: int32 kills = 8
     */
    kills: number;
    /**
     * @generated from protobuf field: double rotation = 9
     */
    rotation: number;
    /**
     * @generated from protobuf field: map<string, int32> bullets_left_by_weapon_type = 10
     */
    bulletsLeftByWeaponType: {
        [key: string]: number;
    };
    /**
     * @generated from protobuf field: double night_vision_timer = 11
     */
    nightVisionTimer: number;
    /**
     * @generated from protobuf field: bool is_alive = 12
     */
    isAlive: boolean;
    /**
     * @generated from protobuf field: repeated protocol.InventoryItem inventory = 14
     */
    inventory: InventoryItem[];
    /**
     * @generated from protobuf field: string selected_gun_type = 15
     */
    selectedGunType: string;
}
/**
 * @generated from protobuf message protocol.Bullet
 */
export interface Bullet {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: protocol.Vector2 velocity = 3
     */
    velocity?: Vector2;
    /**
     * @generated from protobuf field: string owner_id = 4
     */
    ownerId: string;
    /**
     * @generated from protobuf field: float damage = 5
     */
    damage: number;
    /**
     * @generated from protobuf field: bool is_enemy = 6
     */
    isEnemy: boolean;
    /**
     * @generated from protobuf field: bool is_active = 7
     */
    isActive: boolean;
    /**
     * @generated from protobuf field: int64 deleted_at = 10
     */
    deletedAt: bigint;
    /**
     * @generated from protobuf field: int64 inactive_ms = 9
     */
    inactiveMs: bigint;
    /**
     * @generated from protobuf field: string weapon_type = 8
     */
    weaponType: string;
}
/**
 * @generated from protobuf message protocol.Wall
 */
export interface Wall {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: double width = 3
     */
    width: number;
    /**
     * @generated from protobuf field: double height = 4
     */
    height: number;
    /**
     * @generated from protobuf field: string orientation = 5
     */
    orientation: string;
}
/**
 * @generated from protobuf message protocol.Enemy
 */
export interface Enemy {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: double rotation = 3
     */
    rotation: number;
    /**
     * @generated from protobuf field: float lives = 4
     */
    lives: number;
    /**
     * @generated from protobuf field: string wall_id = 5
     */
    wallId: string;
    /**
     * @generated from protobuf field: bool is_alive = 6
     */
    isAlive: boolean;
}
/**
 * @generated from protobuf message protocol.Bonus
 */
export interface Bonus {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: string type = 3
     */
    type: string;
    /**
     * @generated from protobuf field: string picked_up_by = 4
     */
    pickedUpBy: string;
    /**
     * @generated from protobuf field: string dropped_by = 5
     */
    droppedBy: string;
}
/**
 * @generated from protobuf message protocol.ShopItem
 */
export interface ShopItem {
    /**
     * @generated from protobuf field: int32 quantity = 1
     */
    quantity: number;
    /**
     * @generated from protobuf field: int32 pack_size = 2
     */
    packSize: number;
    /**
     * @generated from protobuf field: int32 price = 3
     */
    price: number;
}
/**
 * @generated from protobuf message protocol.Shop
 */
export interface Shop {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: protocol.Vector2 position = 2
     */
    position?: Vector2;
    /**
     * @generated from protobuf field: map<int32, protocol.ShopItem> inventory = 3
     */
    inventory: {
        [key: number]: ShopItem;
    };
    /**
     * @generated from protobuf field: string name = 4
     */
    name: string;
}
/**
 * @generated from protobuf message protocol.InputMessage
 */
export interface InputMessage {
    /**
     * @generated from protobuf field: bool forward = 1
     */
    forward: boolean;
    /**
     * @generated from protobuf field: bool backward = 2
     */
    backward: boolean;
    /**
     * @generated from protobuf field: bool left = 3
     */
    left: boolean;
    /**
     * @generated from protobuf field: bool right = 4
     */
    right: boolean;
    /**
     * @generated from protobuf field: bool shoot = 5
     */
    shoot: boolean;
    /**
     * @generated from protobuf field: map<int32, bool> item_key = 6
     */
    itemKey: {
        [key: number]: boolean;
    };
    /**
     * @generated from protobuf field: map<int32, bool> purchase_item_key = 7
     */
    purchaseItemKey: {
        [key: number]: boolean;
    };
}
/**
 * @generated from protobuf message protocol.PositionUpdate
 */
export interface PositionUpdate {
    /**
     * @generated from protobuf field: double x = 1
     */
    x: number;
    /**
     * @generated from protobuf field: double y = 2
     */
    y: number;
    /**
     * @generated from protobuf field: double rotation = 3
     */
    rotation: number;
}
/**
 * @generated from protobuf message protocol.TimersUpdate
 */
export interface TimersUpdate {
    /**
     * @generated from protobuf field: double invulnerable_timer = 1
     */
    invulnerableTimer: number;
    /**
     * @generated from protobuf field: double night_vision_timer = 2
     */
    nightVisionTimer: number;
}
/**
 * @generated from protobuf message protocol.LivesUpdate
 */
export interface LivesUpdate {
    /**
     * @generated from protobuf field: float lives = 1
     */
    lives: number;
    /**
     * @generated from protobuf field: bool is_alive = 2
     */
    isAlive: boolean;
}
/**
 * @generated from protobuf message protocol.InventoryUpdate
 */
export interface InventoryUpdate {
    /**
     * @generated from protobuf field: repeated protocol.InventoryItem inventory = 1
     */
    inventory: InventoryItem[];
    /**
     * @generated from protobuf field: string selected_gun_type = 2
     */
    selectedGunType: string;
}
/**
 * @generated from protobuf message protocol.ScoreUpdate
 */
export interface ScoreUpdate {
    /**
     * @generated from protobuf field: int32 score = 1
     */
    score: number;
    /**
     * @generated from protobuf field: int32 money = 2
     */
    money: number;
    /**
     * @generated from protobuf field: int32 kills = 3
     */
    kills: number;
}
/**
 * @generated from protobuf message protocol.PlayerBulletsUpdate
 */
export interface PlayerBulletsUpdate {
    /**
     * @generated from protobuf field: map<string, int32> bullets_left_by_weapon_type = 1
     */
    bulletsLeftByWeaponType: {
        [key: string]: number;
    };
}
/**
 * @generated from protobuf message protocol.PlayerUpdate
 */
export interface PlayerUpdate {
    /**
     * @generated from protobuf field: protocol.PositionUpdate position = 1
     */
    position?: PositionUpdate;
    /**
     * @generated from protobuf field: protocol.TimersUpdate timers = 2
     */
    timers?: TimersUpdate;
    /**
     * @generated from protobuf field: protocol.LivesUpdate lives = 3
     */
    lives?: LivesUpdate;
    /**
     * @generated from protobuf field: protocol.InventoryUpdate inventory = 4
     */
    inventory?: InventoryUpdate;
    /**
     * @generated from protobuf field: protocol.ScoreUpdate score = 5
     */
    score?: ScoreUpdate;
    /**
     * @generated from protobuf field: protocol.PlayerBulletsUpdate player_bullets = 6
     */
    playerBullets?: PlayerBulletsUpdate;
}
/**
 * @generated from protobuf message protocol.DeletionUpdate
 */
export interface DeletionUpdate {
    /**
     * @generated from protobuf field: bool is_active = 1
     */
    isActive: boolean;
    /**
     * @generated from protobuf field: int64 deleted_at = 2
     */
    deletedAt: bigint;
}
/**
 * @generated from protobuf message protocol.EnemyUpdate
 */
export interface EnemyUpdate {
    /**
     * @generated from protobuf field: protocol.PositionUpdate position = 1
     */
    position?: PositionUpdate;
    /**
     * @generated from protobuf field: protocol.LivesUpdate lives = 2
     */
    lives?: LivesUpdate;
}
/**
 * @generated from protobuf message protocol.BonusUpdate
 */
export interface BonusUpdate {
    /**
     * @generated from protobuf field: string picked_up_by = 1
     */
    pickedUpBy: string;
}
/**
 * @generated from protobuf message protocol.ShopUpdate
 */
export interface ShopUpdate {
    /**
     * @generated from protobuf field: map<int32, protocol.ShopItem> inventory = 1
     */
    inventory: {
        [key: number]: ShopItem;
    };
}
/**
 * @generated from protobuf message protocol.GameStateDeltaMessage
 */
export interface GameStateDeltaMessage {
    /**
     * @generated from protobuf field: map<string, protocol.Player> added_players = 1
     */
    addedPlayers: {
        [key: string]: Player;
    };
    /**
     * @generated from protobuf field: map<string, protocol.PlayerUpdate> updated_players = 2
     */
    updatedPlayers: {
        [key: string]: PlayerUpdate;
    };
    /**
     * @generated from protobuf field: repeated string removed_players = 3
     */
    removedPlayers: string[];
    /**
     * @generated from protobuf field: map<string, protocol.Bullet> added_bullets = 4
     */
    addedBullets: {
        [key: string]: Bullet;
    };
    /**
     * @generated from protobuf field: map<string, protocol.PositionUpdate> updated_bullets = 5
     */
    updatedBullets: {
        [key: string]: PositionUpdate;
    };
    /**
     * @generated from protobuf field: map<string, protocol.Bullet> removed_bullets = 6
     */
    removedBullets: {
        [key: string]: Bullet;
    };
    /**
     * @generated from protobuf field: map<string, protocol.Wall> added_walls = 7
     */
    addedWalls: {
        [key: string]: Wall;
    };
    /**
     * @generated from protobuf field: repeated string removed_walls = 8
     */
    removedWalls: string[];
    /**
     * @generated from protobuf field: map<string, protocol.Enemy> added_enemies = 9
     */
    addedEnemies: {
        [key: string]: Enemy;
    };
    /**
     * @generated from protobuf field: map<string, protocol.EnemyUpdate> updated_enemies = 10
     */
    updatedEnemies: {
        [key: string]: EnemyUpdate;
    };
    /**
     * @generated from protobuf field: repeated string removed_enemies = 11
     */
    removedEnemies: string[];
    /**
     * @generated from protobuf field: map<string, protocol.Bonus> added_bonuses = 12
     */
    addedBonuses: {
        [key: string]: Bonus;
    };
    /**
     * @generated from protobuf field: map<string, protocol.BonusUpdate> updated_bonuses = 13
     */
    updatedBonuses: {
        [key: string]: BonusUpdate;
    };
    /**
     * @generated from protobuf field: repeated string removed_bonuses = 14
     */
    removedBonuses: string[];
    /**
     * @generated from protobuf field: map<string, protocol.Shop> added_shops = 15
     */
    addedShops: {
        [key: string]: Shop;
    };
    /**
     * @generated from protobuf field: map<string, protocol.ShopUpdate> updated_shops = 16
     */
    updatedShops: {
        [key: string]: ShopUpdate;
    };
    /**
     * @generated from protobuf field: repeated string removed_shops = 17
     */
    removedShops: string[];
    /**
     * @generated from protobuf field: repeated string added_players_shops = 18
     */
    addedPlayersShops: string[];
    /**
     * @generated from protobuf field: repeated string removed_players_shops = 19
     */
    removedPlayersShops: string[];
    /**
     * @generated from protobuf field: map<string, protocol.Vector2> updated_other_player_positions = 20
     */
    updatedOtherPlayerPositions: {
        [key: string]: Vector2;
    };
    /**
     * @generated from protobuf field: repeated string removed_other_player_positions = 21
     */
    removedOtherPlayerPositions: string[];
    /**
     * @generated from protobuf field: int64 timestamp = 22
     */
    timestamp: bigint;
}
/**
 * @generated from protobuf message protocol.PlayerJoinMessage
 */
export interface PlayerJoinMessage {
    /**
     * @generated from protobuf field: protocol.Player player = 1
     */
    player?: Player;
}
/**
 * @generated from protobuf message protocol.PlayerLeaveMessage
 */
export interface PlayerLeaveMessage {
    /**
     * @generated from protobuf field: string player_id = 1
     */
    playerId: string;
}
/**
 * @generated from protobuf message protocol.PlayerRespawnMessage
 */
export interface PlayerRespawnMessage {
}
/**
 * @generated from protobuf message protocol.ErrorMessage
 */
export interface ErrorMessage {
    /**
     * @generated from protobuf field: string message = 1
     */
    message: string;
}
/**
 * Wrapper message
 *
 * @generated from protobuf message protocol.GameMessage
 */
export interface GameMessage {
    /**
     * @generated from protobuf field: protocol.MessageType type = 1
     */
    type: MessageType;
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "input";
        /**
         * @generated from protobuf field: protocol.InputMessage input = 3
         */
        input: InputMessage;
    } | {
        oneofKind: "gameStateDelta";
        /**
         * @generated from protobuf field: protocol.GameStateDeltaMessage game_state_delta = 11
         */
        gameStateDelta: GameStateDeltaMessage;
    } | {
        oneofKind: "playerJoin";
        /**
         * @generated from protobuf field: protocol.PlayerJoinMessage player_join = 6
         */
        playerJoin: PlayerJoinMessage;
    } | {
        oneofKind: "playerLeave";
        /**
         * @generated from protobuf field: protocol.PlayerLeaveMessage player_leave = 7
         */
        playerLeave: PlayerLeaveMessage;
    } | {
        oneofKind: "playerRespawn";
        /**
         * @generated from protobuf field: protocol.PlayerRespawnMessage player_respawn = 8
         */
        playerRespawn: PlayerRespawnMessage;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: protocol.ErrorMessage error = 10
         */
        error: ErrorMessage;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Message types
 *
 * @generated from protobuf enum protocol.MessageType
 */
export enum MessageType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: INPUT = 2;
     */
    INPUT = 2,
    /**
     * @generated from protobuf enum value: GAME_STATE = 5;
     */
    GAME_STATE = 5,
    /**
     * @generated from protobuf enum value: GAME_STATE_DELTA = 11;
     */
    GAME_STATE_DELTA = 11,
    /**
     * @generated from protobuf enum value: PLAYER_JOIN = 6;
     */
    PLAYER_JOIN = 6,
    /**
     * @generated from protobuf enum value: PLAYER_LEAVE = 7;
     */
    PLAYER_LEAVE = 7,
    /**
     * @generated from protobuf enum value: PLAYER_RESPAWN = 8;
     */
    PLAYER_RESPAWN = 8,
    /**
     * @generated from protobuf enum value: ERROR = 10;
     */
    ERROR = 10
}
// @generated message type with reflection information, may provide speed optimized methods
class Vector2$Type extends MessageType$<Vector2> {
    constructor() {
        super("protocol.Vector2", [
            { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Vector2>): Vector2 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<Vector2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Vector2): Vector2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double x */ 1:
                    message.x = reader.double();
                    break;
                case /* double y */ 2:
                    message.y = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Vector2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit64).double(message.x);
        /* double y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit64).double(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Vector2
 */
export const Vector2 = new Vector2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InventoryItem$Type extends MessageType$<InventoryItem> {
    constructor() {
        super("protocol.InventoryItem", [
            { no: 1, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<InventoryItem>): InventoryItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.quantity = 0;
        if (value !== undefined)
            reflectionMergePartial<InventoryItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InventoryItem): InventoryItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* int32 quantity */ 2:
                    message.quantity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InventoryItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* int32 quantity = 2; */
        if (message.quantity !== 0)
            writer.tag(2, WireType.Varint).int32(message.quantity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.InventoryItem
 */
export const InventoryItem = new InventoryItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player$Type extends MessageType$<Player> {
    constructor() {
        super("protocol.Player", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "position", kind: "message", T: () => Vector2 },
            { no: 4, name: "velocity", kind: "message", T: () => Vector2 },
            { no: 5, name: "lives", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "invulnerable_timer", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "money", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "kills", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "rotation", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "bullets_left_by_weapon_type", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 11, name: "night_vision_timer", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "is_alive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "inventory", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => InventoryItem },
            { no: 15, name: "selected_gun_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Player>): Player {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.username = "";
        message.lives = 0;
        message.invulnerableTimer = 0;
        message.score = 0;
        message.money = 0;
        message.kills = 0;
        message.rotation = 0;
        message.bulletsLeftByWeaponType = {};
        message.nightVisionTimer = 0;
        message.isAlive = false;
        message.inventory = [];
        message.selectedGunType = "";
        if (value !== undefined)
            reflectionMergePartial<Player>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Player): Player {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string username */ 2:
                    message.username = reader.string();
                    break;
                case /* protocol.Vector2 position */ 3:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* protocol.Vector2 velocity */ 4:
                    message.velocity = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                case /* float lives */ 5:
                    message.lives = reader.float();
                    break;
                case /* double invulnerable_timer */ 13:
                    message.invulnerableTimer = reader.double();
                    break;
                case /* int32 score */ 6:
                    message.score = reader.int32();
                    break;
                case /* int32 money */ 7:
                    message.money = reader.int32();
                    break;
                case /* int32 kills */ 8:
                    message.kills = reader.int32();
                    break;
                case /* double rotation */ 9:
                    message.rotation = reader.double();
                    break;
                case /* map<string, int32> bullets_left_by_weapon_type */ 10:
                    this.binaryReadMap10(message.bulletsLeftByWeaponType, reader, options);
                    break;
                case /* double night_vision_timer */ 11:
                    message.nightVisionTimer = reader.double();
                    break;
                case /* bool is_alive */ 12:
                    message.isAlive = reader.bool();
                    break;
                case /* repeated protocol.InventoryItem inventory */ 14:
                    message.inventory.push(InventoryItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string selected_gun_type */ 15:
                    message.selectedGunType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: Player["bulletsLeftByWeaponType"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Player["bulletsLeftByWeaponType"] | undefined, val: Player["bulletsLeftByWeaponType"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.Player.bullets_left_by_weapon_type");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: Player, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string username = 2; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* protocol.Vector2 position = 3; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* protocol.Vector2 velocity = 4; */
        if (message.velocity)
            Vector2.internalBinaryWrite(message.velocity, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* float lives = 5; */
        if (message.lives !== 0)
            writer.tag(5, WireType.Bit32).float(message.lives);
        /* int32 score = 6; */
        if (message.score !== 0)
            writer.tag(6, WireType.Varint).int32(message.score);
        /* int32 money = 7; */
        if (message.money !== 0)
            writer.tag(7, WireType.Varint).int32(message.money);
        /* int32 kills = 8; */
        if (message.kills !== 0)
            writer.tag(8, WireType.Varint).int32(message.kills);
        /* double rotation = 9; */
        if (message.rotation !== 0)
            writer.tag(9, WireType.Bit64).double(message.rotation);
        /* map<string, int32> bullets_left_by_weapon_type = 10; */
        for (let k of globalThis.Object.keys(message.bulletsLeftByWeaponType))
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.bulletsLeftByWeaponType[k]).join();
        /* double night_vision_timer = 11; */
        if (message.nightVisionTimer !== 0)
            writer.tag(11, WireType.Bit64).double(message.nightVisionTimer);
        /* bool is_alive = 12; */
        if (message.isAlive !== false)
            writer.tag(12, WireType.Varint).bool(message.isAlive);
        /* double invulnerable_timer = 13; */
        if (message.invulnerableTimer !== 0)
            writer.tag(13, WireType.Bit64).double(message.invulnerableTimer);
        /* repeated protocol.InventoryItem inventory = 14; */
        for (let i = 0; i < message.inventory.length; i++)
            InventoryItem.internalBinaryWrite(message.inventory[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string selected_gun_type = 15; */
        if (message.selectedGunType !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.selectedGunType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Player
 */
export const Player = new Player$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bullet$Type extends MessageType$<Bullet> {
    constructor() {
        super("protocol.Bullet", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "velocity", kind: "message", T: () => Vector2 },
            { no: 4, name: "owner_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "damage", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "is_enemy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "deleted_at", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "inactive_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "weapon_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Bullet>): Bullet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.ownerId = "";
        message.damage = 0;
        message.isEnemy = false;
        message.isActive = false;
        message.deletedAt = 0n;
        message.inactiveMs = 0n;
        message.weaponType = "";
        if (value !== undefined)
            reflectionMergePartial<Bullet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bullet): Bullet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* protocol.Vector2 velocity */ 3:
                    message.velocity = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                case /* string owner_id */ 4:
                    message.ownerId = reader.string();
                    break;
                case /* float damage */ 5:
                    message.damage = reader.float();
                    break;
                case /* bool is_enemy */ 6:
                    message.isEnemy = reader.bool();
                    break;
                case /* bool is_active */ 7:
                    message.isActive = reader.bool();
                    break;
                case /* int64 deleted_at */ 10:
                    message.deletedAt = reader.int64().toBigInt();
                    break;
                case /* int64 inactive_ms */ 9:
                    message.inactiveMs = reader.int64().toBigInt();
                    break;
                case /* string weapon_type */ 8:
                    message.weaponType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bullet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* protocol.Vector2 velocity = 3; */
        if (message.velocity)
            Vector2.internalBinaryWrite(message.velocity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string owner_id = 4; */
        if (message.ownerId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.ownerId);
        /* float damage = 5; */
        if (message.damage !== 0)
            writer.tag(5, WireType.Bit32).float(message.damage);
        /* bool is_enemy = 6; */
        if (message.isEnemy !== false)
            writer.tag(6, WireType.Varint).bool(message.isEnemy);
        /* bool is_active = 7; */
        if (message.isActive !== false)
            writer.tag(7, WireType.Varint).bool(message.isActive);
        /* string weapon_type = 8; */
        if (message.weaponType !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.weaponType);
        /* int64 inactive_ms = 9; */
        if (message.inactiveMs !== 0n)
            writer.tag(9, WireType.Varint).int64(message.inactiveMs);
        /* int64 deleted_at = 10; */
        if (message.deletedAt !== 0n)
            writer.tag(10, WireType.Varint).int64(message.deletedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Bullet
 */
export const Bullet = new Bullet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Wall$Type extends MessageType$<Wall> {
    constructor() {
        super("protocol.Wall", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "width", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "height", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "orientation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Wall>): Wall {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.width = 0;
        message.height = 0;
        message.orientation = "";
        if (value !== undefined)
            reflectionMergePartial<Wall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Wall): Wall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* double width */ 3:
                    message.width = reader.double();
                    break;
                case /* double height */ 4:
                    message.height = reader.double();
                    break;
                case /* string orientation */ 5:
                    message.orientation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Wall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* double width = 3; */
        if (message.width !== 0)
            writer.tag(3, WireType.Bit64).double(message.width);
        /* double height = 4; */
        if (message.height !== 0)
            writer.tag(4, WireType.Bit64).double(message.height);
        /* string orientation = 5; */
        if (message.orientation !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.orientation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Wall
 */
export const Wall = new Wall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Enemy$Type extends MessageType$<Enemy> {
    constructor() {
        super("protocol.Enemy", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "rotation", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "lives", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "wall_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "is_alive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Enemy>): Enemy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.rotation = 0;
        message.lives = 0;
        message.wallId = "";
        message.isAlive = false;
        if (value !== undefined)
            reflectionMergePartial<Enemy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Enemy): Enemy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* double rotation */ 3:
                    message.rotation = reader.double();
                    break;
                case /* float lives */ 4:
                    message.lives = reader.float();
                    break;
                case /* string wall_id */ 5:
                    message.wallId = reader.string();
                    break;
                case /* bool is_alive */ 6:
                    message.isAlive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Enemy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* double rotation = 3; */
        if (message.rotation !== 0)
            writer.tag(3, WireType.Bit64).double(message.rotation);
        /* float lives = 4; */
        if (message.lives !== 0)
            writer.tag(4, WireType.Bit32).float(message.lives);
        /* string wall_id = 5; */
        if (message.wallId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.wallId);
        /* bool is_alive = 6; */
        if (message.isAlive !== false)
            writer.tag(6, WireType.Varint).bool(message.isAlive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Enemy
 */
export const Enemy = new Enemy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bonus$Type extends MessageType$<Bonus> {
    constructor() {
        super("protocol.Bonus", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "picked_up_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "dropped_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Bonus>): Bonus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.type = "";
        message.pickedUpBy = "";
        message.droppedBy = "";
        if (value !== undefined)
            reflectionMergePartial<Bonus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bonus): Bonus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                case /* string picked_up_by */ 4:
                    message.pickedUpBy = reader.string();
                    break;
                case /* string dropped_by */ 5:
                    message.droppedBy = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bonus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* string picked_up_by = 4; */
        if (message.pickedUpBy !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pickedUpBy);
        /* string dropped_by = 5; */
        if (message.droppedBy !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.droppedBy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Bonus
 */
export const Bonus = new Bonus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopItem$Type extends MessageType$<ShopItem> {
    constructor() {
        super("protocol.ShopItem", [
            { no: 1, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "pack_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "price", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ShopItem>): ShopItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.quantity = 0;
        message.packSize = 0;
        message.price = 0;
        if (value !== undefined)
            reflectionMergePartial<ShopItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopItem): ShopItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 quantity */ 1:
                    message.quantity = reader.int32();
                    break;
                case /* int32 pack_size */ 2:
                    message.packSize = reader.int32();
                    break;
                case /* int32 price */ 3:
                    message.price = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShopItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 quantity = 1; */
        if (message.quantity !== 0)
            writer.tag(1, WireType.Varint).int32(message.quantity);
        /* int32 pack_size = 2; */
        if (message.packSize !== 0)
            writer.tag(2, WireType.Varint).int32(message.packSize);
        /* int32 price = 3; */
        if (message.price !== 0)
            writer.tag(3, WireType.Varint).int32(message.price);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.ShopItem
 */
export const ShopItem = new ShopItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Shop$Type extends MessageType$<Shop> {
    constructor() {
        super("protocol.Shop", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Vector2 },
            { no: 3, name: "inventory", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => ShopItem } },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Shop>): Shop {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.inventory = {};
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Shop>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Shop): Shop {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* protocol.Vector2 position */ 2:
                    message.position = Vector2.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* map<int32, protocol.ShopItem> inventory */ 3:
                    this.binaryReadMap3(message.inventory, reader, options);
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: Shop["inventory"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Shop["inventory"] | undefined, val: Shop["inventory"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = ShopItem.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.Shop.inventory");
            }
        }
        map[key ?? 0] = val ?? ShopItem.create();
    }
    internalBinaryWrite(message: Shop, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* protocol.Vector2 position = 2; */
        if (message.position)
            Vector2.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* map<int32, protocol.ShopItem> inventory = 3; */
        for (let k of globalThis.Object.keys(message.inventory)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            ShopItem.internalBinaryWrite(message.inventory[k as any], writer, options);
            writer.join().join();
        }
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.Shop
 */
export const Shop = new Shop$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InputMessage$Type extends MessageType$<InputMessage> {
    constructor() {
        super("protocol.InputMessage", [
            { no: 1, name: "forward", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "backward", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "left", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "right", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "shoot", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "item_key", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } },
            { no: 7, name: "purchase_item_key", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "scalar", T: 8 /*ScalarType.BOOL*/ } }
        ]);
    }
    create(value?: PartialMessage<InputMessage>): InputMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.forward = false;
        message.backward = false;
        message.left = false;
        message.right = false;
        message.shoot = false;
        message.itemKey = {};
        message.purchaseItemKey = {};
        if (value !== undefined)
            reflectionMergePartial<InputMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InputMessage): InputMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool forward */ 1:
                    message.forward = reader.bool();
                    break;
                case /* bool backward */ 2:
                    message.backward = reader.bool();
                    break;
                case /* bool left */ 3:
                    message.left = reader.bool();
                    break;
                case /* bool right */ 4:
                    message.right = reader.bool();
                    break;
                case /* bool shoot */ 5:
                    message.shoot = reader.bool();
                    break;
                case /* map<int32, bool> item_key */ 6:
                    this.binaryReadMap6(message.itemKey, reader, options);
                    break;
                case /* map<int32, bool> purchase_item_key */ 7:
                    this.binaryReadMap7(message.purchaseItemKey, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: InputMessage["itemKey"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof InputMessage["itemKey"] | undefined, val: InputMessage["itemKey"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.InputMessage.item_key");
            }
        }
        map[key ?? 0] = val ?? false;
    }
    private binaryReadMap7(map: InputMessage["purchaseItemKey"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof InputMessage["purchaseItemKey"] | undefined, val: InputMessage["purchaseItemKey"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = reader.bool();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.InputMessage.purchase_item_key");
            }
        }
        map[key ?? 0] = val ?? false;
    }
    internalBinaryWrite(message: InputMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool forward = 1; */
        if (message.forward !== false)
            writer.tag(1, WireType.Varint).bool(message.forward);
        /* bool backward = 2; */
        if (message.backward !== false)
            writer.tag(2, WireType.Varint).bool(message.backward);
        /* bool left = 3; */
        if (message.left !== false)
            writer.tag(3, WireType.Varint).bool(message.left);
        /* bool right = 4; */
        if (message.right !== false)
            writer.tag(4, WireType.Varint).bool(message.right);
        /* bool shoot = 5; */
        if (message.shoot !== false)
            writer.tag(5, WireType.Varint).bool(message.shoot);
        /* map<int32, bool> item_key = 6; */
        for (let k of globalThis.Object.keys(message.itemKey))
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).bool(message.itemKey[k as any]).join();
        /* map<int32, bool> purchase_item_key = 7; */
        for (let k of globalThis.Object.keys(message.purchaseItemKey))
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k)).tag(2, WireType.Varint).bool(message.purchaseItemKey[k as any]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.InputMessage
 */
export const InputMessage = new InputMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionUpdate$Type extends MessageType$<PositionUpdate> {
    constructor() {
        super("protocol.PositionUpdate", [
            { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "rotation", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<PositionUpdate>): PositionUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        message.rotation = 0;
        if (value !== undefined)
            reflectionMergePartial<PositionUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionUpdate): PositionUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double x */ 1:
                    message.x = reader.double();
                    break;
                case /* double y */ 2:
                    message.y = reader.double();
                    break;
                case /* double rotation */ 3:
                    message.rotation = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit64).double(message.x);
        /* double y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit64).double(message.y);
        /* double rotation = 3; */
        if (message.rotation !== 0)
            writer.tag(3, WireType.Bit64).double(message.rotation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.PositionUpdate
 */
export const PositionUpdate = new PositionUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimersUpdate$Type extends MessageType$<TimersUpdate> {
    constructor() {
        super("protocol.TimersUpdate", [
            { no: 1, name: "invulnerable_timer", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "night_vision_timer", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<TimersUpdate>): TimersUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.invulnerableTimer = 0;
        message.nightVisionTimer = 0;
        if (value !== undefined)
            reflectionMergePartial<TimersUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimersUpdate): TimersUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double invulnerable_timer */ 1:
                    message.invulnerableTimer = reader.double();
                    break;
                case /* double night_vision_timer */ 2:
                    message.nightVisionTimer = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimersUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double invulnerable_timer = 1; */
        if (message.invulnerableTimer !== 0)
            writer.tag(1, WireType.Bit64).double(message.invulnerableTimer);
        /* double night_vision_timer = 2; */
        if (message.nightVisionTimer !== 0)
            writer.tag(2, WireType.Bit64).double(message.nightVisionTimer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.TimersUpdate
 */
export const TimersUpdate = new TimersUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LivesUpdate$Type extends MessageType$<LivesUpdate> {
    constructor() {
        super("protocol.LivesUpdate", [
            { no: 1, name: "lives", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "is_alive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LivesUpdate>): LivesUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lives = 0;
        message.isAlive = false;
        if (value !== undefined)
            reflectionMergePartial<LivesUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LivesUpdate): LivesUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float lives */ 1:
                    message.lives = reader.float();
                    break;
                case /* bool is_alive */ 2:
                    message.isAlive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LivesUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float lives = 1; */
        if (message.lives !== 0)
            writer.tag(1, WireType.Bit32).float(message.lives);
        /* bool is_alive = 2; */
        if (message.isAlive !== false)
            writer.tag(2, WireType.Varint).bool(message.isAlive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.LivesUpdate
 */
export const LivesUpdate = new LivesUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InventoryUpdate$Type extends MessageType$<InventoryUpdate> {
    constructor() {
        super("protocol.InventoryUpdate", [
            { no: 1, name: "inventory", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => InventoryItem },
            { no: 2, name: "selected_gun_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InventoryUpdate>): InventoryUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inventory = [];
        message.selectedGunType = "";
        if (value !== undefined)
            reflectionMergePartial<InventoryUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InventoryUpdate): InventoryUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated protocol.InventoryItem inventory */ 1:
                    message.inventory.push(InventoryItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string selected_gun_type */ 2:
                    message.selectedGunType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InventoryUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated protocol.InventoryItem inventory = 1; */
        for (let i = 0; i < message.inventory.length; i++)
            InventoryItem.internalBinaryWrite(message.inventory[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string selected_gun_type = 2; */
        if (message.selectedGunType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.selectedGunType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.InventoryUpdate
 */
export const InventoryUpdate = new InventoryUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScoreUpdate$Type extends MessageType$<ScoreUpdate> {
    constructor() {
        super("protocol.ScoreUpdate", [
            { no: 1, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "money", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "kills", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ScoreUpdate>): ScoreUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.score = 0;
        message.money = 0;
        message.kills = 0;
        if (value !== undefined)
            reflectionMergePartial<ScoreUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScoreUpdate): ScoreUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 score */ 1:
                    message.score = reader.int32();
                    break;
                case /* int32 money */ 2:
                    message.money = reader.int32();
                    break;
                case /* int32 kills */ 3:
                    message.kills = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScoreUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 score = 1; */
        if (message.score !== 0)
            writer.tag(1, WireType.Varint).int32(message.score);
        /* int32 money = 2; */
        if (message.money !== 0)
            writer.tag(2, WireType.Varint).int32(message.money);
        /* int32 kills = 3; */
        if (message.kills !== 0)
            writer.tag(3, WireType.Varint).int32(message.kills);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.ScoreUpdate
 */
export const ScoreUpdate = new ScoreUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerBulletsUpdate$Type extends MessageType$<PlayerBulletsUpdate> {
    constructor() {
        super("protocol.PlayerBulletsUpdate", [
            { no: 1, name: "bullets_left_by_weapon_type", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } }
        ]);
    }
    create(value?: PartialMessage<PlayerBulletsUpdate>): PlayerBulletsUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bulletsLeftByWeaponType = {};
        if (value !== undefined)
            reflectionMergePartial<PlayerBulletsUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerBulletsUpdate): PlayerBulletsUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, int32> bullets_left_by_weapon_type */ 1:
                    this.binaryReadMap1(message.bulletsLeftByWeaponType, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: PlayerBulletsUpdate["bulletsLeftByWeaponType"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PlayerBulletsUpdate["bulletsLeftByWeaponType"] | undefined, val: PlayerBulletsUpdate["bulletsLeftByWeaponType"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.PlayerBulletsUpdate.bullets_left_by_weapon_type");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: PlayerBulletsUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, int32> bullets_left_by_weapon_type = 1; */
        for (let k of globalThis.Object.keys(message.bulletsLeftByWeaponType))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.bulletsLeftByWeaponType[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.PlayerBulletsUpdate
 */
export const PlayerBulletsUpdate = new PlayerBulletsUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerUpdate$Type extends MessageType$<PlayerUpdate> {
    constructor() {
        super("protocol.PlayerUpdate", [
            { no: 1, name: "position", kind: "message", T: () => PositionUpdate },
            { no: 2, name: "timers", kind: "message", T: () => TimersUpdate },
            { no: 3, name: "lives", kind: "message", T: () => LivesUpdate },
            { no: 4, name: "inventory", kind: "message", T: () => InventoryUpdate },
            { no: 5, name: "score", kind: "message", T: () => ScoreUpdate },
            { no: 6, name: "player_bullets", kind: "message", T: () => PlayerBulletsUpdate }
        ]);
    }
    create(value?: PartialMessage<PlayerUpdate>): PlayerUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PlayerUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerUpdate): PlayerUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protocol.PositionUpdate position */ 1:
                    message.position = PositionUpdate.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* protocol.TimersUpdate timers */ 2:
                    message.timers = TimersUpdate.internalBinaryRead(reader, reader.uint32(), options, message.timers);
                    break;
                case /* protocol.LivesUpdate lives */ 3:
                    message.lives = LivesUpdate.internalBinaryRead(reader, reader.uint32(), options, message.lives);
                    break;
                case /* protocol.InventoryUpdate inventory */ 4:
                    message.inventory = InventoryUpdate.internalBinaryRead(reader, reader.uint32(), options, message.inventory);
                    break;
                case /* protocol.ScoreUpdate score */ 5:
                    message.score = ScoreUpdate.internalBinaryRead(reader, reader.uint32(), options, message.score);
                    break;
                case /* protocol.PlayerBulletsUpdate player_bullets */ 6:
                    message.playerBullets = PlayerBulletsUpdate.internalBinaryRead(reader, reader.uint32(), options, message.playerBullets);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protocol.PositionUpdate position = 1; */
        if (message.position)
            PositionUpdate.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* protocol.TimersUpdate timers = 2; */
        if (message.timers)
            TimersUpdate.internalBinaryWrite(message.timers, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* protocol.LivesUpdate lives = 3; */
        if (message.lives)
            LivesUpdate.internalBinaryWrite(message.lives, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* protocol.InventoryUpdate inventory = 4; */
        if (message.inventory)
            InventoryUpdate.internalBinaryWrite(message.inventory, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* protocol.ScoreUpdate score = 5; */
        if (message.score)
            ScoreUpdate.internalBinaryWrite(message.score, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* protocol.PlayerBulletsUpdate player_bullets = 6; */
        if (message.playerBullets)
            PlayerBulletsUpdate.internalBinaryWrite(message.playerBullets, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.PlayerUpdate
 */
export const PlayerUpdate = new PlayerUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletionUpdate$Type extends MessageType$<DeletionUpdate> {
    constructor() {
        super("protocol.DeletionUpdate", [
            { no: 1, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "deleted_at", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<DeletionUpdate>): DeletionUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isActive = false;
        message.deletedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<DeletionUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletionUpdate): DeletionUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_active */ 1:
                    message.isActive = reader.bool();
                    break;
                case /* int64 deleted_at */ 2:
                    message.deletedAt = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletionUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_active = 1; */
        if (message.isActive !== false)
            writer.tag(1, WireType.Varint).bool(message.isActive);
        /* int64 deleted_at = 2; */
        if (message.deletedAt !== 0n)
            writer.tag(2, WireType.Varint).int64(message.deletedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.DeletionUpdate
 */
export const DeletionUpdate = new DeletionUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnemyUpdate$Type extends MessageType$<EnemyUpdate> {
    constructor() {
        super("protocol.EnemyUpdate", [
            { no: 1, name: "position", kind: "message", T: () => PositionUpdate },
            { no: 2, name: "lives", kind: "message", T: () => LivesUpdate }
        ]);
    }
    create(value?: PartialMessage<EnemyUpdate>): EnemyUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EnemyUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnemyUpdate): EnemyUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protocol.PositionUpdate position */ 1:
                    message.position = PositionUpdate.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* protocol.LivesUpdate lives */ 2:
                    message.lives = LivesUpdate.internalBinaryRead(reader, reader.uint32(), options, message.lives);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnemyUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protocol.PositionUpdate position = 1; */
        if (message.position)
            PositionUpdate.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* protocol.LivesUpdate lives = 2; */
        if (message.lives)
            LivesUpdate.internalBinaryWrite(message.lives, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.EnemyUpdate
 */
export const EnemyUpdate = new EnemyUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BonusUpdate$Type extends MessageType$<BonusUpdate> {
    constructor() {
        super("protocol.BonusUpdate", [
            { no: 1, name: "picked_up_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BonusUpdate>): BonusUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pickedUpBy = "";
        if (value !== undefined)
            reflectionMergePartial<BonusUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BonusUpdate): BonusUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string picked_up_by */ 1:
                    message.pickedUpBy = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BonusUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string picked_up_by = 1; */
        if (message.pickedUpBy !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pickedUpBy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.BonusUpdate
 */
export const BonusUpdate = new BonusUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShopUpdate$Type extends MessageType$<ShopUpdate> {
    constructor() {
        super("protocol.ShopUpdate", [
            { no: 1, name: "inventory", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => ShopItem } }
        ]);
    }
    create(value?: PartialMessage<ShopUpdate>): ShopUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inventory = {};
        if (value !== undefined)
            reflectionMergePartial<ShopUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShopUpdate): ShopUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, protocol.ShopItem> inventory */ 1:
                    this.binaryReadMap1(message.inventory, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: ShopUpdate["inventory"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ShopUpdate["inventory"] | undefined, val: ShopUpdate["inventory"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = ShopItem.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.ShopUpdate.inventory");
            }
        }
        map[key ?? 0] = val ?? ShopItem.create();
    }
    internalBinaryWrite(message: ShopUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, protocol.ShopItem> inventory = 1; */
        for (let k of globalThis.Object.keys(message.inventory)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            ShopItem.internalBinaryWrite(message.inventory[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.ShopUpdate
 */
export const ShopUpdate = new ShopUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameStateDeltaMessage$Type extends MessageType$<GameStateDeltaMessage> {
    constructor() {
        super("protocol.GameStateDeltaMessage", [
            { no: 1, name: "added_players", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Player } },
            { no: 2, name: "updated_players", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => PlayerUpdate } },
            { no: 3, name: "removed_players", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "added_bullets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Bullet } },
            { no: 5, name: "updated_bullets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => PositionUpdate } },
            { no: 6, name: "removed_bullets", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Bullet } },
            { no: 7, name: "added_walls", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Wall } },
            { no: 8, name: "removed_walls", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "added_enemies", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Enemy } },
            { no: 10, name: "updated_enemies", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => EnemyUpdate } },
            { no: 11, name: "removed_enemies", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "added_bonuses", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Bonus } },
            { no: 13, name: "updated_bonuses", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => BonusUpdate } },
            { no: 14, name: "removed_bonuses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "added_shops", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Shop } },
            { no: 16, name: "updated_shops", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ShopUpdate } },
            { no: 17, name: "removed_shops", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "added_players_shops", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "removed_players_shops", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "updated_other_player_positions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Vector2 } },
            { no: 21, name: "removed_other_player_positions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GameStateDeltaMessage>): GameStateDeltaMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addedPlayers = {};
        message.updatedPlayers = {};
        message.removedPlayers = [];
        message.addedBullets = {};
        message.updatedBullets = {};
        message.removedBullets = {};
        message.addedWalls = {};
        message.removedWalls = [];
        message.addedEnemies = {};
        message.updatedEnemies = {};
        message.removedEnemies = [];
        message.addedBonuses = {};
        message.updatedBonuses = {};
        message.removedBonuses = [];
        message.addedShops = {};
        message.updatedShops = {};
        message.removedShops = [];
        message.addedPlayersShops = [];
        message.removedPlayersShops = [];
        message.updatedOtherPlayerPositions = {};
        message.removedOtherPlayerPositions = [];
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<GameStateDeltaMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameStateDeltaMessage): GameStateDeltaMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, protocol.Player> added_players */ 1:
                    this.binaryReadMap1(message.addedPlayers, reader, options);
                    break;
                case /* map<string, protocol.PlayerUpdate> updated_players */ 2:
                    this.binaryReadMap2(message.updatedPlayers, reader, options);
                    break;
                case /* repeated string removed_players */ 3:
                    message.removedPlayers.push(reader.string());
                    break;
                case /* map<string, protocol.Bullet> added_bullets */ 4:
                    this.binaryReadMap4(message.addedBullets, reader, options);
                    break;
                case /* map<string, protocol.PositionUpdate> updated_bullets */ 5:
                    this.binaryReadMap5(message.updatedBullets, reader, options);
                    break;
                case /* map<string, protocol.Bullet> removed_bullets */ 6:
                    this.binaryReadMap6(message.removedBullets, reader, options);
                    break;
                case /* map<string, protocol.Wall> added_walls */ 7:
                    this.binaryReadMap7(message.addedWalls, reader, options);
                    break;
                case /* repeated string removed_walls */ 8:
                    message.removedWalls.push(reader.string());
                    break;
                case /* map<string, protocol.Enemy> added_enemies */ 9:
                    this.binaryReadMap9(message.addedEnemies, reader, options);
                    break;
                case /* map<string, protocol.EnemyUpdate> updated_enemies */ 10:
                    this.binaryReadMap10(message.updatedEnemies, reader, options);
                    break;
                case /* repeated string removed_enemies */ 11:
                    message.removedEnemies.push(reader.string());
                    break;
                case /* map<string, protocol.Bonus> added_bonuses */ 12:
                    this.binaryReadMap12(message.addedBonuses, reader, options);
                    break;
                case /* map<string, protocol.BonusUpdate> updated_bonuses */ 13:
                    this.binaryReadMap13(message.updatedBonuses, reader, options);
                    break;
                case /* repeated string removed_bonuses */ 14:
                    message.removedBonuses.push(reader.string());
                    break;
                case /* map<string, protocol.Shop> added_shops */ 15:
                    this.binaryReadMap15(message.addedShops, reader, options);
                    break;
                case /* map<string, protocol.ShopUpdate> updated_shops */ 16:
                    this.binaryReadMap16(message.updatedShops, reader, options);
                    break;
                case /* repeated string removed_shops */ 17:
                    message.removedShops.push(reader.string());
                    break;
                case /* repeated string added_players_shops */ 18:
                    message.addedPlayersShops.push(reader.string());
                    break;
                case /* repeated string removed_players_shops */ 19:
                    message.removedPlayersShops.push(reader.string());
                    break;
                case /* map<string, protocol.Vector2> updated_other_player_positions */ 20:
                    this.binaryReadMap20(message.updatedOtherPlayerPositions, reader, options);
                    break;
                case /* repeated string removed_other_player_positions */ 21:
                    message.removedOtherPlayerPositions.push(reader.string());
                    break;
                case /* int64 timestamp */ 22:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GameStateDeltaMessage["addedPlayers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["addedPlayers"] | undefined, val: GameStateDeltaMessage["addedPlayers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Player.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.added_players");
            }
        }
        map[key ?? ""] = val ?? Player.create();
    }
    private binaryReadMap2(map: GameStateDeltaMessage["updatedPlayers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["updatedPlayers"] | undefined, val: GameStateDeltaMessage["updatedPlayers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = PlayerUpdate.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.updated_players");
            }
        }
        map[key ?? ""] = val ?? PlayerUpdate.create();
    }
    private binaryReadMap4(map: GameStateDeltaMessage["addedBullets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["addedBullets"] | undefined, val: GameStateDeltaMessage["addedBullets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Bullet.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.added_bullets");
            }
        }
        map[key ?? ""] = val ?? Bullet.create();
    }
    private binaryReadMap5(map: GameStateDeltaMessage["updatedBullets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["updatedBullets"] | undefined, val: GameStateDeltaMessage["updatedBullets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = PositionUpdate.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.updated_bullets");
            }
        }
        map[key ?? ""] = val ?? PositionUpdate.create();
    }
    private binaryReadMap6(map: GameStateDeltaMessage["removedBullets"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["removedBullets"] | undefined, val: GameStateDeltaMessage["removedBullets"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Bullet.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.removed_bullets");
            }
        }
        map[key ?? ""] = val ?? Bullet.create();
    }
    private binaryReadMap7(map: GameStateDeltaMessage["addedWalls"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["addedWalls"] | undefined, val: GameStateDeltaMessage["addedWalls"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Wall.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.added_walls");
            }
        }
        map[key ?? ""] = val ?? Wall.create();
    }
    private binaryReadMap9(map: GameStateDeltaMessage["addedEnemies"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["addedEnemies"] | undefined, val: GameStateDeltaMessage["addedEnemies"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Enemy.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.added_enemies");
            }
        }
        map[key ?? ""] = val ?? Enemy.create();
    }
    private binaryReadMap10(map: GameStateDeltaMessage["updatedEnemies"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["updatedEnemies"] | undefined, val: GameStateDeltaMessage["updatedEnemies"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = EnemyUpdate.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.updated_enemies");
            }
        }
        map[key ?? ""] = val ?? EnemyUpdate.create();
    }
    private binaryReadMap12(map: GameStateDeltaMessage["addedBonuses"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["addedBonuses"] | undefined, val: GameStateDeltaMessage["addedBonuses"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Bonus.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.added_bonuses");
            }
        }
        map[key ?? ""] = val ?? Bonus.create();
    }
    private binaryReadMap13(map: GameStateDeltaMessage["updatedBonuses"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["updatedBonuses"] | undefined, val: GameStateDeltaMessage["updatedBonuses"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = BonusUpdate.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.updated_bonuses");
            }
        }
        map[key ?? ""] = val ?? BonusUpdate.create();
    }
    private binaryReadMap15(map: GameStateDeltaMessage["addedShops"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["addedShops"] | undefined, val: GameStateDeltaMessage["addedShops"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Shop.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.added_shops");
            }
        }
        map[key ?? ""] = val ?? Shop.create();
    }
    private binaryReadMap16(map: GameStateDeltaMessage["updatedShops"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["updatedShops"] | undefined, val: GameStateDeltaMessage["updatedShops"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ShopUpdate.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.updated_shops");
            }
        }
        map[key ?? ""] = val ?? ShopUpdate.create();
    }
    private binaryReadMap20(map: GameStateDeltaMessage["updatedOtherPlayerPositions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateDeltaMessage["updatedOtherPlayerPositions"] | undefined, val: GameStateDeltaMessage["updatedOtherPlayerPositions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Vector2.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for protocol.GameStateDeltaMessage.updated_other_player_positions");
            }
        }
        map[key ?? ""] = val ?? Vector2.create();
    }
    internalBinaryWrite(message: GameStateDeltaMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, protocol.Player> added_players = 1; */
        for (let k of globalThis.Object.keys(message.addedPlayers)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Player.internalBinaryWrite(message.addedPlayers[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.PlayerUpdate> updated_players = 2; */
        for (let k of globalThis.Object.keys(message.updatedPlayers)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            PlayerUpdate.internalBinaryWrite(message.updatedPlayers[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_players = 3; */
        for (let i = 0; i < message.removedPlayers.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.removedPlayers[i]);
        /* map<string, protocol.Bullet> added_bullets = 4; */
        for (let k of globalThis.Object.keys(message.addedBullets)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Bullet.internalBinaryWrite(message.addedBullets[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.PositionUpdate> updated_bullets = 5; */
        for (let k of globalThis.Object.keys(message.updatedBullets)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            PositionUpdate.internalBinaryWrite(message.updatedBullets[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.Bullet> removed_bullets = 6; */
        for (let k of globalThis.Object.keys(message.removedBullets)) {
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Bullet.internalBinaryWrite(message.removedBullets[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.Wall> added_walls = 7; */
        for (let k of globalThis.Object.keys(message.addedWalls)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Wall.internalBinaryWrite(message.addedWalls[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_walls = 8; */
        for (let i = 0; i < message.removedWalls.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.removedWalls[i]);
        /* map<string, protocol.Enemy> added_enemies = 9; */
        for (let k of globalThis.Object.keys(message.addedEnemies)) {
            writer.tag(9, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Enemy.internalBinaryWrite(message.addedEnemies[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.EnemyUpdate> updated_enemies = 10; */
        for (let k of globalThis.Object.keys(message.updatedEnemies)) {
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            EnemyUpdate.internalBinaryWrite(message.updatedEnemies[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_enemies = 11; */
        for (let i = 0; i < message.removedEnemies.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.removedEnemies[i]);
        /* map<string, protocol.Bonus> added_bonuses = 12; */
        for (let k of globalThis.Object.keys(message.addedBonuses)) {
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Bonus.internalBinaryWrite(message.addedBonuses[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.BonusUpdate> updated_bonuses = 13; */
        for (let k of globalThis.Object.keys(message.updatedBonuses)) {
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            BonusUpdate.internalBinaryWrite(message.updatedBonuses[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_bonuses = 14; */
        for (let i = 0; i < message.removedBonuses.length; i++)
            writer.tag(14, WireType.LengthDelimited).string(message.removedBonuses[i]);
        /* map<string, protocol.Shop> added_shops = 15; */
        for (let k of globalThis.Object.keys(message.addedShops)) {
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Shop.internalBinaryWrite(message.addedShops[k], writer, options);
            writer.join().join();
        }
        /* map<string, protocol.ShopUpdate> updated_shops = 16; */
        for (let k of globalThis.Object.keys(message.updatedShops)) {
            writer.tag(16, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ShopUpdate.internalBinaryWrite(message.updatedShops[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_shops = 17; */
        for (let i = 0; i < message.removedShops.length; i++)
            writer.tag(17, WireType.LengthDelimited).string(message.removedShops[i]);
        /* repeated string added_players_shops = 18; */
        for (let i = 0; i < message.addedPlayersShops.length; i++)
            writer.tag(18, WireType.LengthDelimited).string(message.addedPlayersShops[i]);
        /* repeated string removed_players_shops = 19; */
        for (let i = 0; i < message.removedPlayersShops.length; i++)
            writer.tag(19, WireType.LengthDelimited).string(message.removedPlayersShops[i]);
        /* map<string, protocol.Vector2> updated_other_player_positions = 20; */
        for (let k of globalThis.Object.keys(message.updatedOtherPlayerPositions)) {
            writer.tag(20, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Vector2.internalBinaryWrite(message.updatedOtherPlayerPositions[k], writer, options);
            writer.join().join();
        }
        /* repeated string removed_other_player_positions = 21; */
        for (let i = 0; i < message.removedOtherPlayerPositions.length; i++)
            writer.tag(21, WireType.LengthDelimited).string(message.removedOtherPlayerPositions[i]);
        /* int64 timestamp = 22; */
        if (message.timestamp !== 0n)
            writer.tag(22, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.GameStateDeltaMessage
 */
export const GameStateDeltaMessage = new GameStateDeltaMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerJoinMessage$Type extends MessageType$<PlayerJoinMessage> {
    constructor() {
        super("protocol.PlayerJoinMessage", [
            { no: 1, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<PlayerJoinMessage>): PlayerJoinMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PlayerJoinMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerJoinMessage): PlayerJoinMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protocol.Player player */ 1:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerJoinMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protocol.Player player = 1; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.PlayerJoinMessage
 */
export const PlayerJoinMessage = new PlayerJoinMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerLeaveMessage$Type extends MessageType$<PlayerLeaveMessage> {
    constructor() {
        super("protocol.PlayerLeaveMessage", [
            { no: 1, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerLeaveMessage>): PlayerLeaveMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerId = "";
        if (value !== undefined)
            reflectionMergePartial<PlayerLeaveMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerLeaveMessage): PlayerLeaveMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_id */ 1:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerLeaveMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_id = 1; */
        if (message.playerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.PlayerLeaveMessage
 */
export const PlayerLeaveMessage = new PlayerLeaveMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerRespawnMessage$Type extends MessageType$<PlayerRespawnMessage> {
    constructor() {
        super("protocol.PlayerRespawnMessage", []);
    }
    create(value?: PartialMessage<PlayerRespawnMessage>): PlayerRespawnMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PlayerRespawnMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerRespawnMessage): PlayerRespawnMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerRespawnMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.PlayerRespawnMessage
 */
export const PlayerRespawnMessage = new PlayerRespawnMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorMessage$Type extends MessageType$<ErrorMessage> {
    constructor() {
        super("protocol.ErrorMessage", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ErrorMessage>): ErrorMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ErrorMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorMessage): ErrorMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.ErrorMessage
 */
export const ErrorMessage = new ErrorMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameMessage$Type extends MessageType$<GameMessage> {
    constructor() {
        super("protocol.GameMessage", [
            { no: 1, name: "type", kind: "enum", T: () => ["protocol.MessageType", MessageType] },
            { no: 3, name: "input", kind: "message", oneof: "payload", T: () => InputMessage },
            { no: 11, name: "game_state_delta", kind: "message", oneof: "payload", T: () => GameStateDeltaMessage },
            { no: 6, name: "player_join", kind: "message", oneof: "payload", T: () => PlayerJoinMessage },
            { no: 7, name: "player_leave", kind: "message", oneof: "payload", T: () => PlayerLeaveMessage },
            { no: 8, name: "player_respawn", kind: "message", oneof: "payload", T: () => PlayerRespawnMessage },
            { no: 10, name: "error", kind: "message", oneof: "payload", T: () => ErrorMessage }
        ]);
    }
    create(value?: PartialMessage<GameMessage>): GameMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<GameMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameMessage): GameMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* protocol.MessageType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* protocol.InputMessage input */ 3:
                    message.payload = {
                        oneofKind: "input",
                        input: InputMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).input)
                    };
                    break;
                case /* protocol.GameStateDeltaMessage game_state_delta */ 11:
                    message.payload = {
                        oneofKind: "gameStateDelta",
                        gameStateDelta: GameStateDeltaMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).gameStateDelta)
                    };
                    break;
                case /* protocol.PlayerJoinMessage player_join */ 6:
                    message.payload = {
                        oneofKind: "playerJoin",
                        playerJoin: PlayerJoinMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).playerJoin)
                    };
                    break;
                case /* protocol.PlayerLeaveMessage player_leave */ 7:
                    message.payload = {
                        oneofKind: "playerLeave",
                        playerLeave: PlayerLeaveMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).playerLeave)
                    };
                    break;
                case /* protocol.PlayerRespawnMessage player_respawn */ 8:
                    message.payload = {
                        oneofKind: "playerRespawn",
                        playerRespawn: PlayerRespawnMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).playerRespawn)
                    };
                    break;
                case /* protocol.ErrorMessage error */ 10:
                    message.payload = {
                        oneofKind: "error",
                        error: ErrorMessage.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* protocol.MessageType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* protocol.InputMessage input = 3; */
        if (message.payload.oneofKind === "input")
            InputMessage.internalBinaryWrite(message.payload.input, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* protocol.PlayerJoinMessage player_join = 6; */
        if (message.payload.oneofKind === "playerJoin")
            PlayerJoinMessage.internalBinaryWrite(message.payload.playerJoin, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* protocol.PlayerLeaveMessage player_leave = 7; */
        if (message.payload.oneofKind === "playerLeave")
            PlayerLeaveMessage.internalBinaryWrite(message.payload.playerLeave, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* protocol.PlayerRespawnMessage player_respawn = 8; */
        if (message.payload.oneofKind === "playerRespawn")
            PlayerRespawnMessage.internalBinaryWrite(message.payload.playerRespawn, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* protocol.ErrorMessage error = 10; */
        if (message.payload.oneofKind === "error")
            ErrorMessage.internalBinaryWrite(message.payload.error, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* protocol.GameStateDeltaMessage game_state_delta = 11; */
        if (message.payload.oneofKind === "gameStateDelta")
            GameStateDeltaMessage.internalBinaryWrite(message.payload.gameStateDelta, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message protocol.GameMessage
 */
export const GameMessage = new GameMessage$Type();
